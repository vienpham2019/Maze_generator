{"version":3,"sources":["Algorithms/solve_maze/breadth_first_search.js","Algorithms/solve_maze/depth_first_search.js","Algorithms/solve_maze/a_star.js","Algorithms/solve_maze/greedy_best_first_search.js","Algorithms/solve_maze/dijkstra.js","Algorithms/solve_maze/bidirectional_dijkstra.js","Algorithms/solve_maze/bidirectional_a_star.js","Algorithms/self_solve.js","Algorithms/draw_maze/recursive_division_maze_generation.js","Algorithms/draw_maze/prims_maze_generation.js","Algorithms/draw_maze/depth_first_search_maze_generation.js","Algorithms/mazeController.js","Algorithms/helper_method.js","Algorithms/solve_maze/helper_method/algorithms_helper_method.js","App.js","reducer/mazeGeneratorReducer.js","index.js"],"names":["c","canvas","size","nodes","default_nodes","start_node","end_node","speed","visited_nodes","quere","current_node","finish_path","myReq","stack","open_list","close_list","close_list_1","close_list_2","open_list_1","current_node_1","open_list_2","current_node_2","finish_search","current_path","find_path","delay","cols","rows","frame_per_second","neighbors_node","visited_neighbors_node","current_neighbor_node","myReqDraw","block","width","height","select_draw_algorithims","start_location","end_location","Node","x","y","walls","neighbor_node","prev_node","this","grid","draw","color","beginPath","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","every","e","rect","fillStyle","fill","Block","g","h","f","distance","Infinity","rect_size","r","arcTo","closePath","Stack","items","count","keys","key","val","push","pop","Object","values","get_top_right_bottom_left","node","array","top","get","right","bottom","left","stop_breadth_first_search","clearTimeout","run_solve_maze","setTimeout","clearRect","solve_maze","quere_nodes","slice","shift","check_neighbor_node","add_node","wall_num","has","new_block","set","stop_depth_first_search","v_node","peek","stop_a_star","remove_key","delete","find_child_node","node_in_open","n_g","update_node","new_node","set_node","x_1","y_1","x_2","y_2","Math","abs","parent","stop_greedy_best_first_search","stop_dijkstra","create_new_node","find_distance","stop_bidirectional_dijkstra","print_close_and_open_list","find_current_node","list","list_num","c_node","close_color","open_color","open_node","close_node","next_close_list","neighbor_close_list","check_for_mix_node","stop_bidirectional_a_star","target_node","target_close_list","stop_self_solve","window","removeEventListener","set_up","addEventListener","find_next_step","path","star_size","draw_finish_path","requestAnimationFrame","cancelAnimationFrame","wall_number","draw_maze","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","neightbor_node","min","max","floor","random","setup_prims_maze","w","midd_x","midd_y","center_node","draw_prims_maze","clearInterval","add_neighbor_node","create_neighbor_node","link_node_with_random_neighbor","random_num","random_neighbor","Array","from","length","move_block","neighbor_nodes","next_node","unshift","left_right","up_down","setUp","props","create_node","draw_divide_maze","myTimeOut","not_walls","store","Map","i","j","depth_first_search_maze","prims_maze","draw_delay","recursive_dividion_maze","check_recursive_delay","algorithms","clear_path","depth_first_search","breadth_first_search","dijkstra","greedy_best_first_search","bidirectional_a_star","bidirectional_dijkstra","self_solve","update_info","n","set_walls","select_start","select_end","select_wall","display_points","add_event","App","run_set_point","refs","maze","state","innerWidth","innerHeight","offsetLeft","offsetTop","setState","pageX","pageY","value","dispay_draw_button","updateCanvas","generate_speed","getContext","swal","button","content","className","select_solve_algorithims","speeds","solve_speed","solve_maze_algorithims","draw_maze_algorithims","start_x","start_y","end_x","end_y","class","style","minWidth","onChange","target","map","algorithm","selected","for","s","type","placeholder","onClick","position","backgroundColor","ref","Component","connect","init_state","mazeGenerationReducer","createStore","mazeGeneratorReducer","_REDUX_DEVTOOLS_EXTENSION_","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f296759c.chunk.js","sourcesContent":["import {Block} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size , nodes, default_nodes , start_node , end_node , speed \n    \nlet visited_nodes ,  quere , current_node , finish_path , myReq\n\nconst breadth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    nodes = props.nodes \n    default_nodes = props.default_nodes\n\n    finish_path = false \n    current_node = null  \n    start_node = props.start_node\n    end_node = props.end_node\n    start_node.color = 'MediumBlue' \n    quere = [start_node]\n    visited_nodes = new Map([\n        [`${start_node.x} , ${start_node.y}` , start_node]\n    ])\n\n    end_node.prev_node = null\n\n    speed = props.speed \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_breadth_first_search = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes.values()){\n        node.draw('silver')\n    }\n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    for(let v_node of visited_nodes.values()){\n        v_node.draw()\n    }\n\n    if(end_node.prev_node && !finish_path){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path()\n    }\n\n    if(!end_node.prev_node && !finish_path){\n        solve_maze()\n    }\n    \n    if(finish_path){\n        clearTimeout(myReq)\n    }\n}\n  \nconst solve_maze = () => {\n    let quere_nodes = quere.slice()\n    quere.shift()\n    if(end_node.prev_node){\n        return\n    }\n    for(let node of quere_nodes){\n        check_neighbor_node(node)\n    }\n}\n  \nconst check_neighbor_node = (node) => {\n    let { top , right , bottom , left } = get_top_right_bottom_left(node , nodes , size)\n    // top \n    add_node(top , node , 2)\n\n    // right\n    add_node(right , node , 3)\n\n    // bottom\n    add_node(bottom , node , 0)\n\n    // left \n    add_node(left , node , 1)\n}\n\nconst add_node = (neighbor_node , node , wall_num) => {\n    let color = 'MediumBlue' \n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        && !visited_nodes.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n        ){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n        }else{\n            let new_block = new Block(x, y , c , size , color, node)\n            quere.push(new_block)\n            visited_nodes.set(`${new_block.x} , ${new_block.y}` , new_block)\n        }\n    }\n    return \n}\n  \nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n    }\n    current_node = current_node.prev_node\n}\n\nexport { breadth_first_search ,  stop_breadth_first_search}\n\n","import {Block , Stack} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size ,  nodes, default_nodes , start_node , end_node , speed\n    \nlet visited_nodes , stack , current_node ,  finish_path , myReq\n\nconst depth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    nodes = props.nodes \n    default_nodes = props.default_nodes\n\n    finish_path = false  \n    start_node = props.start_node\n    end_node = props.end_node\n    speed = props.speed\n\n    end_node.prev_node = null\n\n    stack = new Stack()\n    visited_nodes = new Map()\n    visited_nodes.set(`${start_node.x} , ${start_node.y}` , start_node)\n    current_node = start_node \n\n    stack.push(`${start_node.x} , ${start_node.y}` , start_node)\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_depth_first_search = () => {\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    // myReq = requestAnimationFrame(run_solve_maze)\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n    for(let node of default_nodes.values()){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    for(let v_node of visited_nodes.values()){\n        if(!end_node.prev_node){\n            v_node.color = 'MediumBlue' \n        }\n        v_node.draw()\n    }\n\n    if(!end_node.prev_node){\n        for(let node of stack.values()){\n            node.color = 'LightSkyBlue' \n            node.draw()\n        }\n    }\n\n    if(stack.count > 0 && !end_node.prev_node){\n        current_node = stack.peek()\n        if(!check_neighbor_node()){\n            stack.pop()\n        }\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        clearTimeout(myReq)\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nconst check_neighbor_node = () => {\n    let {top , right , bottom , left } = get_top_right_bottom_left(current_node , nodes , size)\n\n    // bottom\n    if(add_node(bottom , 0)) return true \n\n    // right\n    if(add_node(right , 3)) return true \n\n    // top \n    if(add_node(top , 2)) return true \n\n    // left \n    if(add_node(left , 1)) return true \n\n    return false \n}\n\nconst add_node = (neighbor_node, wall_num) => {\n    let color = 'MediumBlue'\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        && !visited_nodes.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = current_node\n        }else{\n            let new_block = new Block(x, y, c , size ,color , current_node)\n            stack.push(`${new_block.x} , ${new_block.y}` , new_block)\n            visited_nodes.set(`${new_block.x} , ${new_block.y}` , new_block)\n        }\n        return true \n    }\n    return false \n}\n\nexport { depth_first_search ,  stop_depth_first_search}","import { Block } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed \n\nlet open_list , close_list , current_node , myReq\n\nconst a_star = props => {\n    start_node   = props.start_node \n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed\n\n    end_node.prev_node = null\n\n    open_list = new Map([\n        [`${start_node.x} , ${start_node.y}` , start_node]\n    ])\n    close_list = new Map()\n    current_node = null\n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_a_star = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes.values()) {\n        node.draw('silver')\n    }\n\n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    for(let node of close_list.values()){\n        if(!end_node.prev_node){\n            node.color = 'MediumBlue'\n        }\n        node.draw()\n    }\n\n    for(let node of open_list.values()){\n        node.color = 'LightSkyBlue'\n        node.draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.size > 0 && !end_node.prev_node){\n        let remove_key = null\n        for(let [key , node] of open_list){\n            if(remove_key === null || node.f < current_node.f) {\n                remove_key = key \n                current_node = node\n            }\n        }\n        open_list.delete(remove_key)\n\n        close_list.set(`${current_node.x} , ${current_node.y}` , current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node && current_node){\n        current_node.color = \"SpringGreen\"\n        current_node.draw()\n        current_node = current_node.prev_node\n    }\n\n    if(current_node === null){\n        clearTimeout(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    // left (x - size , y )\n    add_node(left , 1)\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&  !close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.get(`${x} , ${y}`)\n        let n_g = current_node.g + size\n\n        if(node_in_open){\n            if(node_in_open.g > n_g) update_node(node_in_open, n_g , current_node ) \n        }else{\n            let new_node = set_node(neighbor_node, n_g)\n            open_list.set(`${new_node.x} , ${new_node.y}` , new_node)\n        }\n    }\n}\n\nconst set_node = (node, g) => {\n    let color = 'MediumBlue'\n    let [x_1 , y_1] = [node.x , node.y] \n    let [x_2 , y_2] = [end_node.x , end_node.y] \n    let h = Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)\n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {a_star , stop_a_star}","import { Block} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst greedy_best_first_search = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed\n\n    end_node.prev_node = null\n    \n    open_list = new Map([ \n        [`${start_node.x} , ${start_node.y}` , start_node]\n    ])\n    close_list = new Map()\n    current_node = null\n    finish_path = false \n\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_greedy_best_first_search = () => {\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    // myReq = requestAnimationFrame(run_solve_maze)\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n    \n    for(let node of default_nodes.values()){\n        node.draw('silver')\n    }\n\n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    for(let node of close_list.values()){\n        if(!end_node.prev_node){\n            node.color = 'MediumBlue'\n        }\n        node.draw()\n    }\n\n    for(let node of open_list.values()){\n        node.color = 'LightSkyBlue' \n        node.draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.size > 0 && !end_node.prev_node){\n        current_node = null\n        for(let node of open_list.values()){\n            if(current_node === null || node.h < current_node.h) current_node = node\n        }\n        close_list.set(`${current_node.x} , ${current_node.y}` , current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n    if(finish_path){\n        // cancelAnimationFrame(myReq)\n        clearTimeout(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    // open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n    open_list.delete(`${current_node.x} , ${current_node.y}`)\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        if(!open_list.has(`${x} , ${y}`)) open_list.set(`${x} , ${y}` , set_node(neighbor_node))\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst set_node = (node) => {\n    let color = 'MediumBlue'\n    let [x_1 , y_1] = [node.x , node.y]\n    let [x_2 , y_2] = [end_node.x , end_node.y]   \n    let h = Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)\n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , null , h )\n    return new_node \n}\n\nexport {greedy_best_first_search , stop_greedy_best_first_search}\n\n","import { Block , Stack} from '../helper_method'\n\nimport {get_top_right_bottom_left } from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes, c , canvas , size , speed \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed \n\n    end_node.prev_node = null\n    \n    open_list = new Map([\n        [`${start_node.x} , ${start_node.y}` , start_node]\n    ])\n    close_list = new Map()\n    current_node = null \n    finish_path = false \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_dijkstra = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes.values()){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    for(let node of close_list.values()){\n        if(!end_node.prev_node){\n            node.color = 'MediumBlue'\n        }\n        node.draw()\n    }\n\n    for(let node of open_list.values()){\n        if(!end_node.prev_node){\n            node.color = 'LightSkyBlue' \n        }\n        node.draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.size > 0 && !end_node.prev_node){\n        let remove_key = null \n        for(let [key , node] of open_list){\n            if(remove_key === null || node.distance < current_node.distance) {\n                remove_key = key \n                current_node = node\n            }\n        }\n        open_list.delete(remove_key)\n\n        close_list.set(`${current_node.x} , ${current_node.y}` , current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        clearTimeout(myReq)\n    }\n}\n\nconst find_child_node = () => {\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.get(`${x} , ${y}`)\n        \n        if(node_in_open){\n            update_node(node_in_open)\n        }else{\n            let new_node = create_new_node(neighbor_node)\n            open_list.set(`${new_node.x} , ${new_node.y}` , new_node)\n        }\n            \n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst create_new_node = (node) => {\n    let distance = find_distance(node)\n    return new Block(node.x , node.y , c , size , 'MediumBlue' , current_node , null , null , null , distance)\n}\n\nconst find_distance = (node) => {\n    // find distance from current node to next node \n    let [x_1 , y_1] = [current_node.x , current_node.y ]\n\n    let [x_2 , y_2] = [node.x , node.y]\n\n   return Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2) + current_node.distance\n}\n\nconst update_node = node => {\n    if(current_node.distance + size < node.distance){\n        node.distance = find_distance(node)\n    }\n}\n\nexport {dijkstra , stop_dijkstra}","import { Block , Stack } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed  \n\nlet close_list_1 , close_list_2 , open_list_1 , current_node_1 , open_list_2, current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    \n    end_node = props.end_node \n    end_node.distance = 0\n\n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed \n    \n    open_list_1 = new Map([\n        [`${start_node.x} , ${start_node.y}` , start_node]\n    ])\n    close_list_1 = new Map()\n\n    open_list_2 = new Map([\n        [`${end_node.x} , ${end_node.y}` , end_node]\n    ])\n    close_list_2 = new Map()\n\n    current_node_1 = start_node\n    current_node_2 = end_node \n\n    finish_path = false \n    finish_search = false \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_dijkstra = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes.values()){\n        node.draw('silver')\n    }\n\n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_2.size > 0 && !finish_search){\n        find_current_node(open_list_2 , 2)\n        close_list_2.set(`${current_node_2.x} , ${current_node_2.y}` , current_node_2)\n        open_list_2 = find_child_node(current_node_2 , open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(open_list_1.size > 0 && !finish_search){\n        find_current_node(open_list_1 , 1)\n        close_list_1.set(`${current_node_1.x} , ${current_node_1.y}` , current_node_1)\n        open_list_1 = find_child_node(current_node_1 , open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n\n        find_path() \n    }\n\n    if(finish_path){\n        // cancelAnimationFrame(myReq)\n        clearTimeout(myReq)\n    }\n}\n\nconst find_current_node = (list , list_num) => {\n    let c_node = null \n    let remove_key = null \n    for(let [key , node] of list){\n        if(c_node === null || node.distance < c_node.distance) {\n            c_node = node \n            remove_key = key \n        } \n    }\n    list.delete(remove_key)\n    if(list_num === 1){\n        open_list_1 = list \n        current_node_1 = c_node \n    }else{\n        open_list_2 = list \n        current_node_2 = c_node \n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color ) => {\n    if(!finish_search){\n        for(let open_node of open_list.values()){\n            open_node.color = open_color\n            open_node.draw()\n        }\n    }\n\n    for(let close_node of close_list.values()){\n        if(!finish_search){\n            close_node.color = close_color \n        }\n        close_node.draw()\n    }\n}\n\nconst check_for_mix_node = (next_close_list , x , y) => {\n    let node = next_close_list.get(`${x} , ${y}`)\n    if(node){\n        finish_search = true \n        if(close_list_1.has(`${x} , ${y}`)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , open_list , close_list , next_close_list) => {\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // Right (x + size , y)\n    add_node(right , c_node , 3 , close_list , open_list , next_close_list) // 3\n\n    // top (x , y - size)\n    add_node(top , c_node , 2 , close_list , open_list , next_close_list) // 2\n\n    // left (x - size , y )\n    add_node(left , c_node , 1 , close_list , open_list , next_close_list) // 1\n\n    // bottom (x , y + size)\n    add_node(bottom , c_node , 0 , close_list , open_list , next_close_list) // 0\n\n    return open_list\n}\n\nconst add_node = (neighbor_node , c_node , wall_num , close_list , open_list , neighbor_close_list) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n        ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.get(`${x} , ${y}`)\n        \n        if(!check_for_mix_node(neighbor_close_list , x , y)){\n            if(node_in_open){\n                update_node(node_in_open , c_node) \n            } else{\n                let new_node = create_new_node(neighbor_node , c_node)\n                open_list.set(`${new_node.x} , ${new_node.y}` , new_node)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst create_new_node = (node , c_node) => {\n    let distance = find_distance(node , c_node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , c_node , null , null , null , distance)\n}\n\nconst find_distance = (node , c_node) => {\n    // find distance from current node to next node \n    let [ x_1 , y_1 ]= [ c_node.x , c_node.y ] \n\n    let [ x_2 , y_2 ] = [ node.x , node.y ] \n\n   return Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2) + c_node.distance\n}\n\nconst update_node = (node , c_node) => {\n    if(c_node.distance + size < node.distance){\n        node.distance = find_distance(node , c_node)\n    }\n    return node\n}\n\nexport {bidirectional_dijkstra , stop_bidirectional_dijkstra}","import { Block , Stack } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed \n\nlet open_list_1 , close_list_1 , current_node_1 , open_list_2 , close_list_2 , current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed \n\n    open_list_1 = new Map([  \n        [`${start_node.x} , ${start_node.y}` , start_node]\n    ])\n    close_list_1 = new Map()\n\n    open_list_2 = new Map([\n        [`${end_node.x} , ${end_node.y}` , end_node]\n    ])\n    close_list_2 = new Map()\n\n    current_node_1 = null \n    current_node_2 = null \n\n    finish_path = false \n    finish_search = false \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_a_star = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n    \n    for(let node of default_nodes.values()) {\n        node.draw('silver')\n    }\n\n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_1.size > 0 && !finish_search){\n        find_current_node(open_list_1 , 1)\n\n        close_list_1.set(`${current_node_1.x} , ${current_node_1.y}` , current_node_1)\n        open_list_1 = find_child_node(current_node_1 , end_node, open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(open_list_2.size > 0 && !finish_search){\n        find_current_node(open_list_2 , 2)\n\n        close_list_2.set(`${current_node_2.x} , ${current_node_2.y}` , current_node_2)\n        open_list_2 = find_child_node(current_node_2 , start_node, open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2) finish_path = true\n        find_path() \n    }\n\n    if(finish_path){\n        clearTimeout(myReq)\n    }\n}\n\nconst find_current_node = (list , list_num) => {\n    let c_node = null \n    let remove_key = null\n    for(let [key , node] of list){\n        if(c_node === null || node.f < c_node.f){\n            c_node = node \n            remove_key = key \n        }\n    }\n\n    list.delete(remove_key)\n\n    if(list_num === 1){\n        open_list_1 = list \n        current_node_1 = c_node \n    }else{\n        open_list_2 = list \n        current_node_2 = c_node \n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color) => {\n    if(!finish_search){\n        for(let open_node of open_list.values()){\n            open_node.color = open_color\n            open_node.draw()\n        }\n    }\n\n    for(let close_node of close_list.values()){\n        if(!finish_search) close_node.color = close_color \n        close_node.draw()\n    }\n}\n\nconst check_for_mix_node = (target_close_list , x , y) => {\n    let node = target_close_list.get(`${x} , ${y}`)\n    if(node){\n        finish_search = true \n        if(close_list_1.has(`${x} , ${y}`)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , target_node , open_list , close_list , target_close_list) => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(c_node , right , 3 , close_list , open_list , target_close_list , target_node)\n\n    // top (x , y - size)\n    add_node(c_node , top , 2 , close_list , open_list , target_close_list , target_node)\n\n    // left (x - size , y )\n    add_node(c_node , left , 1 , close_list , open_list , target_close_list , target_node)\n\n    // bottom (x , y + size)\n    add_node(c_node , bottom , 0 , close_list , open_list , target_close_list , target_node)\n\n    return open_list\n}\n\nconst add_node = (c_node , neighbor_node , wall_num , close_list , open_list , target_close_list , target_node) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        && !close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node \n        let node_in_open = open_list.get(`${x} , ${y}`)\n        let n_g = c_node.g + size\n\n        if(!check_for_mix_node(target_close_list , x , y)){\n            if(node_in_open){ \n                if(n_g < node_in_open.g) update_node(node_in_open, n_g , c_node )\n            }else{\n                let new_node = set_node(neighbor_node , n_g , c_node , target_node)\n                open_list.set(`${new_node.x} , ${new_node.y}` , new_node)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst set_node = (node, g , c_node , target_node) => {\n    let color = \"MediumBlue\"\n    let [x_1 , y_1] = [node.x , node.y] \n    let [x_2 , y_2] = [target_node.x , target_node.y]  \n    let h = Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2) \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , c_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {bidirectional_a_star , stop_bidirectional_a_star}","import { Block , Stack} from './helper_method'\nimport {get_top_right_bottom_left} from './solve_maze/helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size \n\nlet current_node , current_path , myReq , find_path \n\nconst self_solve = props => {\n    start_node = props.start_node\n    current_node = start_node \n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    find_path = false \n\n    current_path = new Stack()\n    current_path.push(`${current_node.x} , ${current_node.y}` , set_node(current_node))\n    set_up()\n}\n\nconst stop_self_solve = () => {\n    window.removeEventListener(\"keydown\" , run_solve_maze)\n}\n\nconst set_up = () => {\n    c.clearRect(0,0,canvas.width, canvas.height)\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n    for(let node of nodes){\n        node.draw()\n    }\n    stop_self_solve()\n    window.addEventListener(\"keydown\" , run_solve_maze)\n}\n\nconst run_solve_maze = e => {\n        c.clearRect(0,0,canvas.width, canvas.height)\n        current_node = current_path.peek()\n        let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n        switch (e.key) {\n            case \"a\":\n                find_next_step(left , 1)\n                break \n            case \"w\":\n                find_next_step(top , 2)\n                break \n            case \"d\":\n                find_next_step(right , 3)\n                break \n            case \"s\":\n                find_next_step(bottom , 0)\n                break \n        }\n        for(let node of default_nodes){\n            node.draw('silver')\n        }\n        for(let node of nodes){\n            node.draw()\n        }\n        for(let path of current_path.values()){\n            path.star_size = size \n            path.color = \"MediumBlue\"\n            current_path.peek().color = \"LightSkyBlue\"\n            path.draw()\n        }\n        if(find_path) {\n            stop_self_solve()\n            current_node = current_path.peek()\n            draw_finish_path()\n        }\n}\n\nconst draw_finish_path = () => {\n    myReq = requestAnimationFrame(draw_finish_path)\n    current_node.color = \"SpringGreen\"\n    current_node.draw()\n    current_node = current_node.prev_node\n\n    if(!current_node) cancelAnimationFrame(myReq)\n}\n\nconst find_next_step = (node , wall_number) => {\n    if(node && !node.walls[wall_number]){\n        let {x , y} = node \n        let key = '' + x + y \n        if(end_node.x === x && end_node.y === y) find_path = true \n        if(!current_path.has(key)){\n            current_path.push(key , set_node(node))\n        }else{\n            current_path.pop()\n        }\n    }\n\n}\n\nconst set_node = (node) => {\n    let color = \"MediumBlue\"\n    let {x , y} = node \n    let new_node = new Block(x, y , c , size , color , current_path.peek())\n    return new_node \n}\n\nexport {self_solve , stop_self_solve}","let delay , speed , size , cols , rows , nodes\n\nconst recursive_dividion_maze = (props) => {\n    delay = props.delay\n    speed = props.speed \n    size = props.size \n    cols = props.cols \n    rows = props.rows\n    nodes = props.nodes\n\n    return draw_maze(nodes , cols , rows , 0, 0 , delay , speed , size)\n}\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n    if(x_max - x_min < 1 || y_max - y_min < 1) return\n  \n    let random_x = getRandom(x_min,x_max)\n    let random_y = getRandom(y_min,y_max)\n    let x_or_y = getRandom(-20, 20) \n  \n    delay ++\n  \n    setTimeout(() => {\n      for(let node of nodes_array.values()){\n          if(x_or_y > 0) { // x\n              if (\n                  node.x === random_x * size + (size / 2) \n                  && node.y <= y_max * size + (size / 2)\n                  && node.y >= y_min * size + (size / 2)\n                  && node.x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (node.y !== random_y * size + (size / 2)){\n                      node.walls[1] = true\n                      let {x , y} = node\n                      let neightbor_node = nodes_array.get(`${x + size} , ${y}`) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  node.y === random_y * size + (size / 2)\n                  && node.x <= x_max * size + (size / 2)\n                  && node.x >= x_min * size + (size / 2)\n                  ){\n                  if(node.x !== random_x * size + (size / 2)){\n                      node.walls[2] = true\n                      let {x , y} = node\n                      let neightbor_node = nodes_array.get(`${x} , ${y + size}`) \n                      if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            node.draw()\n        }\n    }, delay * speed)\n  \n    if(x_or_y > 0){ \n      draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n    }else{\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n      draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n    }\n  \n    return delay \n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {recursive_dividion_maze}","import {get_top_right_bottom_left} from '../solve_maze/helper_method/algorithms_helper_method'\nimport { Stack } from '../helper_method'\n\nlet size , nodes , default_nodes , cols , rows , canvas , c , frame_per_second , speed \nlet neighbors_node , visited_neighbors_node , current_neighbor_node , myReqDraw \nconst prims_maze = props => {\n    size = props.size\n    nodes = props.nodes \n    default_nodes = props.default_nodes\n    cols = props.cols \n    rows = props.rows \n    canvas = props.canvas \n    c = props.c \n\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    neighbors_node = new Map()\n    visited_neighbors_node = new Map()\n    current_neighbor_node = null \n    \n    clearInterval(myReqDraw)\n    setup_prims_maze(nodes , cols , rows)\n}\n\nconst stop_prims_draw_maze = () => {\n    clearInterval(myReqDraw)\n}\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n    let midd_x =  Math.floor(w / 2) * size + (size / 2)\n    let midd_y =  Math.floor(h / 2) * size + (size / 2)\n    let center_node = nodes_array.get(`${midd_x} , ${midd_y}`)\n    neighbors_node.set(`${center_node.x} , ${center_node.y}` , center_node)\n    visited_neighbors_node.set(`${center_node.x} , ${center_node.y}` , center_node)\n    current_neighbor_node = center_node\n\n    draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n    myReqDraw = setTimeout(() => {\n        draw_prims_maze()\n    }, frame_per_second / speed)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes.values()){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    if(neighbors_node.size === 0){\n        clearInterval(myReqDraw)\n    }\n\n    add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n    let {x , y} = current_neighbor_node\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes , size) \n\n    // top \n    create_neighbor_node(top)\n\n    // right \n    create_neighbor_node(right)\n\n    //bottom \n    create_neighbor_node(bottom)\n\n    //left \n    create_neighbor_node(left)\n\n    neighbors_node.delete(`${x} , ${y}`)\n\n    link_node_with_random_neighbor()\n}\n\nconst create_neighbor_node = (neighbor_node) => {\n    if(\n        neighbor_node \n        && !visited_neighbors_node.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n        && !neighbors_node.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        neighbors_node.set(`${neighbor_node.x} , ${neighbor_node.y}` , neighbor_node)\n        neighbor_node.prev_node = current_neighbor_node\n    }\n}\n\nconst link_node_with_random_neighbor = () => {\n    if(neighbors_node.size <= 0) return\n    let random_num = getRandom(0 , neighbors_node.size)\n    let random_neighbor = Array.from(neighbors_node.values())[random_num]\n    \n    let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor, visited_neighbors_node, size)\n\n    if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[0] = false \n        top.walls[2] = false\n    }\n\n    if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[1] = false \n        right.walls[3] = false\n    }\n\n    if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[2] = false \n        bottom.walls[0] = false\n    }\n\n    if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[3] = false \n        left.walls[1] = false\n    }\n    current_neighbor_node = random_neighbor\n    visited_neighbors_node.set(`${random_neighbor.x} , ${random_neighbor.y}` , random_neighbor)\n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {prims_maze , stop_prims_draw_maze}\n\n","import {Block} from '../helper_method'\n\nlet nodes , default_nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed \n\nlet block , myReq , visited_nodes , width , height \n\nconst depth_first_search_maze = props => {\n    nodes = props.nodes \n    default_nodes = props.default_nodes\n    canvas = props.canvas \n    c = props.c \n    stack = props.stack\n    size = props.size\n    cols = props.cols \n    rows = props.rows\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    block = new Block(size / 2,size / 2 , c , size)\n\n    width = cols * size \n    height = rows * size  \n\n    let start_node = nodes.get(`${size / 2} , ${size / 2}`)\n\n    visited_nodes = new Map([\n        [`${start_node.x} , ${start_node.y}`, start_node]\n    ])\n\n    clearInterval(myReq)\n    draw_maze()\n}\n\nconst stop_depth_first_search_draw_maze = () => {\n    clearInterval(myReq)\n}\n\nconst draw_maze = () => {\n    myReq = setTimeout(() => {\n        draw_maze()\n    }, frame_per_second / speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes.values()){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes.values()){\n        node.draw()\n    }\n\n    if(stack.length === 0){\n        clearInterval(myReq)\n    }else{ \n        move_block()  \n    }\n}\n\nconst move_block = () => {\n    let current_node = stack[0]\n    let neighbor_nodes = []\n    let x = current_node.x\n    let y = current_node.y\n\n    // top\n    if(y - size > 0 && !visited_nodes.has(`${x} , ${y - size}`)){\n        let top = nodes.get(`${x} , ${y - size}`)\n        neighbor_nodes.push(top)\n    }\n\n    // right \n    if(x + size < width && !visited_nodes.has(`${x + size} , ${y}`)){\n        let right = nodes.get(`${x + size} , ${y}`)\n        neighbor_nodes.push(right)\n    }\n\n    // bottom\n    if(y + size < height && !visited_nodes.has(`${x} , ${y + size}`)){\n        let bottom = nodes.get(`${x} , ${y + size}`)\n        neighbor_nodes.push(bottom)\n    }\n\n    // left\n    if(x - size > 0 && !visited_nodes.has(`${x - size} , ${y}`)){\n        let left = nodes.get(`${x - size} , ${y}`)\n        neighbor_nodes.push(left)\n    }\n\n    if(neighbor_nodes.length > 0){\n        let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)]\n        stack.unshift(next_node)\n        visited_nodes.set(`${next_node.x} , ${next_node.y}` , next_node)\n        let left_right = next_node.x - current_node.x\n        let up_down = next_node.y - current_node.y\n\n        if(left_right > 0) { // right \n            current_node.walls[1] = false \n            next_node.walls[3] = false \n        }else if(left_right < 0){ // left\n            current_node.walls[3] = false \n            next_node.walls[1] = false \n        } \n\n        if(up_down > 0) { // down\n            current_node.walls[2] = false \n            next_node.walls[0] = false \n        }else if(up_down < 0){ // up\n            current_node.walls[0] = false \n            next_node.walls[2] = false \n        }\n        block.x = next_node.x \n        block.y = next_node.y\n    }else{\n        block.x = current_node.x \n        block.y = current_node.y\n        stack.shift()\n    }\n    block.draw()\n}\n\nexport {depth_first_search_maze , stop_depth_first_search_draw_maze}","import { Node , Block } from './helper_method'\nimport { breadth_first_search , stop_breadth_first_search }from './solve_maze/breadth_first_search'\nimport { depth_first_search , stop_depth_first_search }from './solve_maze/depth_first_search'\nimport { a_star , stop_a_star }from './solve_maze/a_star'\nimport { greedy_best_first_search , stop_greedy_best_first_search }from './solve_maze/greedy_best_first_search'\nimport { dijkstra , stop_dijkstra }from './solve_maze/dijkstra'\nimport { bidirectional_dijkstra , stop_bidirectional_dijkstra }from './solve_maze/bidirectional_dijkstra'\nimport { bidirectional_a_star , stop_bidirectional_a_star }from './solve_maze/bidirectional_a_star'\n\nimport {self_solve , stop_self_solve} from './self_solve'\n\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation'\nimport { prims_maze , stop_prims_draw_maze} from './draw_maze/prims_maze_generation'\nimport { depth_first_search_maze , stop_depth_first_search_draw_maze } from './draw_maze/depth_first_search_maze_generation'\n\nimport {get_top_right_bottom_left} from './solve_maze/helper_method/algorithms_helper_method'\n\nlet size , width , height , cols , rows , select_draw_algorithims , speed \n\nlet delay, canvas , c , start_node, end_node , nodes , default_nodes , stack , frame_per_second , maze_speed , myTimeOut , start_location , end_location \n\nconst setUp = (props) => {\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_bidirectional_dijkstra()\n  stop_greedy_best_first_search()\n  stop_bidirectional_a_star()\n  stop_self_solve()\n\n  stop_depth_first_search_draw_maze()\n  stop_prims_draw_maze()\n\n  c = props.c\n  canvas = props.canvas \n  stack = []\n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = props.width\n  height = props.height\n  select_draw_algorithims = props.select_draw_algorithims\n\n  size = Math.floor(width / cols)\n\n  start_location = {x: size / 2 , y: size / 2}\n  end_location = {x: (cols - 1) * size + (size / 2) , y: (rows - 1) * size + (size / 2)}\n\n  delay = 0 \n  speed = props.speed\n  maze_speed = 700\n\n  frame_per_second = 1000\n\n  canvas.width = width\n  canvas.height = height\n\n  nodes = create_node(\n        select_draw_algorithims === \"Recursive Division\" \n    ||  select_draw_algorithims === \" Default Grid \"\n  )\n  default_nodes = create_node(false)\n  draw_divide_maze(props)\n  clearTimeout(myTimeOut)\n  return nodes\n}\n\nconst create_node = (not_walls) => {\n  let store = new Map()\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n      let walls = not_walls\n        ? [false , false , false ,false]  \n        : [true , true , true , true]\n\n      let x = j * size + (size / 2)\n      let y = i * size + (size / 2)\n      let node = new Node(x, y , c , size , walls)\n      if(select_draw_algorithims !== \" Default Grid \"){\n        if(i === 0){\n          node.walls[0] = true\n        }else if(i === rows - 1){\n          node.walls[2] = true\n        }\n\n        if(j === 0){\n          node.walls[3] = true\n        }else if(j === cols - 1){\n          node.walls[1] = true\n        }\n\n        if(i === 0 && j === 0) {\n            node.walls[0] = false \n        }\n        if(j === cols - 1 && i === rows - 1){\n          node.walls[1] = false\n        }\n\n        if(i === 0 && j === 0){\n            stack.push(node)\n        }\n      }\n      // store.push(node)\n      store.set(`${x} , ${y}` , node)\n    }\n  }\n  return store\n}\n\nconst draw_divide_maze = (props) => {\n\n  start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n\n  for(let node of default_nodes.values()){\n    node.draw('silver')\n  }\n\n  switch (select_draw_algorithims) {\n    case \"Depth first search\":\n      depth_first_search_maze({nodes , default_nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed })\n      break\n    case \"Prim's\": \n      prims_maze({size , nodes , default_nodes , cols , rows , canvas , c , frame_per_second , speed})\n      break \n    case \"Recursive Division\": \n      let draw_delay = recursive_dividion_maze({delay , speed , size , cols , rows , nodes})\n      if(draw_delay){\n        setTimeout(() => {\n            props.check_recursive_delay(true)\n          }, draw_delay * speed);\n        }\n      break \n  }\n\n}\n\nconst run_solve_maze = (algorithms , speed) => {\n  clear_path()\n\n  switch (algorithms) {\n    case \"A star\":\n      a_star({start_node , end_node , nodes , default_nodes , c , canvas , size , speed})\n      break\n    case \"Depth first search\": \n      depth_first_search({nodes , default_nodes , start_node , end_node , c , canvas , size , speed})\n      break\n    case \"Breadth first search\": \n      breadth_first_search({c , canvas , size , nodes , default_nodes , start_node , end_node , speed})\n      break \n    case \"Dijkstra's\": \n      dijkstra({start_node , end_node , nodes, default_nodes , c , canvas , size , speed})\n      break \n    case \"Greedy best first search\": \n      greedy_best_first_search({start_node , end_node , nodes , default_nodes , c , canvas , size , speed})\n      break \n    case \"Bidirectional a star\": \n      bidirectional_a_star({start_node , end_node , nodes , default_nodes , c , canvas , size , speed})\n      break \n    case \"Bidirectional dijkstra's\": \n      bidirectional_dijkstra({start_node , end_node , nodes , default_nodes , c , canvas , size , speed})\n      break \n    default: \n      self_solve({nodes , default_nodes , start_node , end_node , c , canvas , size})\n      break \n  }\n}\n\nconst update_info = props => {\n  if(props.start_location){\n    start_location = props.start_location\n    let c_node = nodes.get(`${start_node.x} , ${start_node.y}`)\n    if(c_node.walls.every(n => n === true)) c_node.walls = new Array(4).fill(!c_node.walls[0])\n    \n    start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  }\n\n  if(props.end_location){\n    end_location = props.end_location\n    let c_node = nodes.get(`${end_location.x} , ${end_location.y}`)\n    if(c_node.walls.every(n => n === true)) c_node.walls = new Array(4).fill(!c_node.walls[0])\n      \n    end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n  }\n\n  if(props.set_walls){\n    let {x , y} = props.set_walls\n    nodes.get(`${x} , ${y}`).walls = new Array(4).fill(!nodes.get(`${x} , ${y}`).walls[0])\n  }\n\n  c.clearRect(0,0,canvas.width, canvas.height)\n  clear_path()\n  for(let node of default_nodes.values()) {\n    node.draw('silver')\n  }\n\n  for(let node of nodes.values()) {\n    node.draw()\n  }\n}\n\nconst clear_path = () => {\n  stop_greedy_best_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_bidirectional_dijkstra()\n  stop_bidirectional_a_star()\n\n  stop_self_solve()\n}\n\nexport {setUp , run_solve_maze , update_info}\n","\n\nconst Node = function(x , y , c , size , walls , neighbor_node = [], prev_node = null){\n    this.x = x\n    this.y = y\n    this.neighbor_node = neighbor_node\n    this.prev_node = prev_node \n    this.walls = walls// [top, right , bottom , left ]\n    this.grid = false \n\n    this.draw = (color = \"black\") => {\n        let x = this.x - (size / 2)\n        let y = this.y - (size / 2)\n        // Top \n        if(this.walls[0]){\n            c.beginPath()\n            c.moveTo(x, y)\n            c.lineTo(x + size , y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // right\n        if(this.walls[1]){\n            c.beginPath()\n            c.moveTo(x + size, y)\n            c.lineTo(x + size , y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // bottom\n        if(this.walls[2]){\n            c.beginPath()\n            c.moveTo(x + size, y + size)\n            c.lineTo(x, y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // left \n        if(this.walls[3]){\n            c.beginPath()\n            c.moveTo(x, y + size)\n            c.lineTo(x, y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        if(this.walls.every( e => e === true) && this.grid){\n            c.beginPath()\n            c.rect(x, y, size, size)\n            c.fillStyle = 'black'\n            c.fill()\n        }\n    }\n}\n\nconst Block = function(x , y , c , size, color = \"red\", prev_node = null , g = null , h = null , f = null , distance = Infinity){\n    this.x = x \n    this.y = y \n    this.prev_node = prev_node\n    this.color = color\n    this.g = g \n    this.h = h \n    this.f = f\n    this.c = c \n    this.distance = distance\n    this.size = size \n  \n    this.draw = () => {\n        let x = this.x - (this.size / 3) \n        let y = this.y - (this.size / 3)\n        let rect_size = this.size * 2/3\n        let r = rect_size * 1/4\n        this.c.beginPath()\n        this.c.moveTo(x+r, y)\n        this.c.arcTo(x+rect_size, y,   x+rect_size, y+rect_size, r)\n        this.c.arcTo(x+rect_size, y+rect_size, x,   y+rect_size, r)\n        this.c.arcTo(x,   y+rect_size, x,   y,   r)\n        this.c.arcTo(x,   y,   x+rect_size, y,   r)\n        this.c.fillStyle = this.color\n        this.c.fill()\n        // this.c.fillStyle = 'black'\n        // this.c.fillText(this.f , x , y)\n        // this.c.fillText(this.h , x + 10 , y + 10)\n        // this.c.fillText(this.g , x + 20 , y + 20)\n        this.c.closePath()\n    }\n}\n\nclass Stack {\n    constructor() {\n      this.items = {};\n      this.count = 0;\n      this.keys = []\n    }\n    \n    getLength() {\n      return this.count;\n    }\n    \n    push(key , val) {\n        this.items[key] = val; \n        this.count += 1;\n        this.keys.push(key) \n    }\n    \n    pop() {\n      if(this.count > 0) {\n        delete this.items[this.keys[--this.count]]\n        this.keys.pop()\n      }\n    }\n    \n    peek() {\n      return this.items[this.keys[this.count - 1]];\n    }\n\n    values(){\n        return Object.values(this.items)\n    }\n}\n\nexport {Node , Block , Stack}","const get_top_right_bottom_left = (node , array , size) => {\n    if(!node) return null\n    let {x , y} = node\n    let top = array.get(`${x} , ${y - size}`)\n    let right = array.get(`${x + size} , ${y}`)\n    let bottom = array.get(`${x} , ${y + size}`)\n    let left = array.get(`${x - size} , ${y}`)\n\n    return {top , right , bottom , left }\n}\n\n\nexport {get_top_right_bottom_left}","import React , {Component} from 'react'\nimport {setUp , run_solve_maze , update_info} from './Algorithms/mazeController'\nimport {connect} from 'react-redux'\nimport swal from '@sweetalert/with-react'\n\nlet select_start = false\nlet select_end = false \nlet select_wall = false \nlet display_points = false \nlet add_event = false \n\nclass App extends Component{\n  constructor(){\n    super()\n    this.state = {\n      width: (window.innerWidth * .95),\n      height: (window.innerHeight * .92),\n      select_draw_algorithims: \" Default Grid \", \n      select_solve_algorithims: \"A star\",\n      rows: 15, \n      dispay_draw_button: true , \n      generate_speed: \"Normal\", \n      start_location: {x: 40 , y: 170}, \n      end_location: {x: 40 , y: 170}, \n      speeds: {\"Slow\": 200 , \"Normal\": 100 , \"Fast\": 50, \"Very Fast\": 10}, \n      solve_speed: 50 \n    }\n  }\n\n  componentDidMount(){\n    display_points = true\n    this.setState({select_draw_algorithims: \" Default Grid \"})\n    this.updateCanvas()\n    this.run_set_point()\n  }\n\n  run_set_point = () => {\n    let canvas = this.refs.maze\n    let {width , rows} = this.state \n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n    let size = Math.floor(width / cols)\n    let {offsetLeft , offsetTop} = canvas\n    let start_location = {x: offsetLeft + (size / 2) , y: offsetTop + (size / 2)}\n    let end_location = {x: offsetLeft + ((cols - 1) * size + (size / 2)) , y: offsetTop + ((rows - 1) * size + (size / 2))}\n    this.setState({start_location , end_location})\n\n    if(!add_event){\n      canvas.addEventListener('mousedown' , e => {\n        add_event = true\n        \n        let {width , rows} = this.state \n        let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n        let size = Math.floor(width / cols)\n\n        let {pageX , pageY} = e\n        let x = Math.floor(((pageX - offsetLeft) / size)) * (size) + (size / 2) + offsetLeft\n        let y = Math.floor(((pageY - offsetTop) / size)) * (size) + (size / 2) + offsetTop\n        if(x < (cols * size) + offsetLeft && y < (rows * size) + offsetTop){\n          if(select_end){\n            end_location = {x , y}\n            this.setState({end_location})\n            update_info({end_location: {x: x - offsetLeft ,y: y - offsetTop}})\n          }\n    \n          if(select_start){\n            start_location = {x , y}\n            this.setState({start_location})\n            update_info({start_location: {x: x - offsetLeft ,y: y - offsetTop}})\n          }\n    \n          if(select_wall){\n            update_info({set_walls: {x: x - offsetLeft ,y: y - offsetTop}})\n          }\n        }\n      })\n    }\n  }\n\n  check_recursive_delay = (value) => {\n    this.setState({dispay_draw_button: value})\n  }\n\n  updateCanvas = (select_draw_algorithims = this.state.select_draw_algorithims) => {\n    // rows == min 15 and max 50\n    let {rows , height , width } = this.state\n\n    let speed = this.props.speed[select_draw_algorithims][this.state.generate_speed]\n\n    if(select_draw_algorithims === \"Recursive Division\"){\n      this.check_recursive_delay(false)\n    }\n\n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n\n    const canvas = this.refs.maze\n    const c = canvas.getContext('2d');\n\n    if(rows < 15 || rows > 50){\n      swal({\n        button: false, \n        content: (\n          <div className=\"p-2 bg-white\">\n            <h3 className=\"bg-white\">Rows should be minimum 15 and maximum 50.</h3>\n          </div>\n        )\n      })\n      return\n    }\n    setUp({c , canvas , cols , rows, width , height , select_draw_algorithims , \n    check_recursive_delay: this.check_recursive_delay , speed })\n  }\n\n  render(){\n    let {width , height , select_solve_algorithims , select_draw_algorithims , dispay_draw_button} = this.state\n    let {solve_maze_algorithims , draw_maze_algorithims} = this.props\n    let speed = [\"Slow\", \"Normal\", \"Fast\" , \"Very Fast\"]\n    \n    let [start_x , start_y] = [this.state.start_location.x , this.state.start_location.y]\n\n    let [end_x , end_y]  = [this.state.end_location.x , this.state.end_location.y]\n\n    return(\n      <div className=\"mt-3\">\n        <div className=\"container border-right border-bottom p-3 border-secondary shadow-sm p-3 mb-5\">\n          <h2 className=\"ml-2\">The Maze Generatetor</h2>\n          <div className=\"row\">\n            {/* Generate maze controller */}\n            <div className=\"col border-right\">\n              <div class=\"form-group\">\n                <label>Algorithms</label>\n                <select \n                  className=\"custom-select\" \n                  style={{minWidth: 250}}\n                  onChange={(e) => this.setState({select_draw_algorithims: e.target.value})}\n                >\n                  {draw_maze_algorithims.map(algorithm => \n                    select_draw_algorithims === \" Default Grid \"\n                      ? <option value={algorithm} selected>{algorithm}</option>\n                      : <option value={algorithm}>{algorithm}</option>\n                  )}\n                </select>\n              </div>\n              <div class=\"form-group\">\n                <label for=\"exampleInputPassword1\">Speed</label>\n                <select \n                  className=\"custom-select\" \n                  onChange={(e) => this.setState({generate_speed: e.target.value})}\n                >\n                  {speed.map(s => \n                    s === \"Normal\"\n                      ? <option value={s} selected>{s}</option>\n                      : <option value={s} >{s}</option>\n                  )}\n                </select>\n              </div>\n              <div className=\"form-group\">\n                <label for=\"exampleInputPassword1\">Rows</label>\n                <input \n                  type=\"number\" \n                  className=\"form-control\" \n                  min='15' max='50'\n                  placeholder=\"Minimum 15 and Maximum 50\"\n                  style={{minWidth: 100}}\n                  onChange={(e) => {\n                    this.setState({rows: Math.floor(e.target.value)})\n                  }}\n                ></input>\n              </div>\n              <div className=\"input-group-append\">\n                <button \n                  className=\"btn btn-outline-dark w-100 my-3\" \n                  onClick={() => {\n                    display_points = true\n                    if(dispay_draw_button){\n                      select_start = select_end = select_wall = false\n                      this.updateCanvas()\n                      this.run_set_point()\n                    }\n                  }}\n                >\n                  Generate Maze\n                </button>\n              </div>\n            </div>\n            \n            {/* Solve maze controller */}\n            <div className=\"col\">\n              <div class=\"form-group\">\n                <label>Algorithms</label>\n                <select \n                  className=\"custom-select\" \n                  onChange={(e) => this.setState({select_solve_algorithims: e.target.value})}\n                >\n                  {solve_maze_algorithims.map(algorithm => \n                    <option value={algorithm}>{algorithm}</option>\n                  )}\n                </select>\n              </div>\n              <div className=\"form-group\">\n                <label for=\"exampleInputPassword1\">Speed</label>\n                <select \n                  className=\"custom-select\" \n                  onChange={(e) => this.setState({solve_speed: this.state.speeds[e.target.value]})}\n                >\n                  {speed.map(s => \n                    s === \"Normal\"\n                      ? <option value={s} selected>{s}</option>\n                      : <option value={s} >{s}</option>\n                  )}\n                </select>\n              </div>\n              <div className = \"form-group\">\n                <label>Select start and end points</label><br/>\n\n              {/* Start point button */}\n                <button \n                  className=\"btn mx-2\" \n                  style={{color: select_start ? 'black' :'white'}}\n                  onClick={() => {\n                    select_end = select_wall = false\n                    select_start = !select_start\n                    this.setState({})\n                  }}\n                >\n                  <i class=\"fas fa-star\" style={{color: select_start ? 'black' :'white'}}></i> Start Point\n                </button>\n\n              {/* End point button */}\n                <button \n                  className=\"btn mx-2\" \n                  style={{color: select_end ? 'black' :'white'}}\n                  onClick={() => {\n                    select_start = select_wall = false\n                    select_end = !select_end \n                    this.setState({})\n                  }}\n                >\n                  <i class=\"fas fa-bullseye\" style={{color: select_end ? 'black' :'white'}}></i> End Point\n                </button>\n                \n              {/* Wall button */}\n              {select_draw_algorithims === \" Default Grid \" ? \n                <button \n                  className=\"btn mx-2\" \n                  style={{color: select_wall ? 'black' :'white'}}\n                  onClick={() => {\n                    select_end = select_start = false\n                    select_wall = !select_wall\n                    this.setState({})\n                  }}\n                >\n                  <i class=\"fas fa-square\" style={{color: select_wall ? 'black' :'white'}}></i> Walls\n                </button>\n              : null} \n                <label className=\"text-info\">\n                  {select_solve_algorithims === \" Self-Solve \" ? \"Use W | S to control forward and backward A | D for left and right.\" : \"\"}\n                </label>\n              </div>\n              <div className=\"input-group-append\">\n                <button \n                  className=\"btn btn-outline-dark w-100\" \n                  type=\"button\"\n                  onClick={() => {\n                    run_solve_maze(select_solve_algorithims , this.state.solve_speed)\n                  }}\n                >\n                  Solve Maze\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* Maze canvas */}\n        <div className=\"m-5\">\n          {display_points ? \n            <i \n              class=\"fas fa-star text-white\" \n              style={{position: \"absolute\", width: 10 , height: 10, top: start_y - 10, left: start_x - 10 , backgroundColor: 'transparent'}}></i>\n          : null } \n          {display_points ? \n            <i \n              class=\"fas fa-bullseye text-white\" \n              style={{position: \"absolute\", width: 6, height: 6, top: end_y - 6, left: end_x - 6 , backgroundColor: 'transparent'}}></i>\n          : null }\n          <canvas ref=\"maze\" style={{width, height}}></canvas>\n        </div> \n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = state => {\n  return {\n    draw_maze_algorithims: state.draw_maze_algorithims,\n    solve_maze_algorithims: state.solve_maze_algorithims,\n    speed: state.speed \n  }\n}\n\nexport default connect(mapStateToProps)(App)\n","let init_state = {\n    draw_maze_algorithims: [\"Depth first search\" , \"Prim's\" , \"Recursive Division\" , \" Default Grid \"], \n    solve_maze_algorithims: [\"A star\" , \"Depth first search\" , \"Breadth first search\" , \"Dijkstra's\" , \"Greedy best first search\" , \"Bidirectional a star\" , \"Bidirectional dijkstra's\", \" Self-Solve \"], \n    rows: 15,\n    speed: {\n        \"Depth first search\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Very Fast\": 300\n        },\n        \"Prim's\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Very Fast\": 300\n        },\n        \"Recursive Division\": {\n            \"Very Fast\": 10, \n            \"Fast\": 50, \n            \"Normal\": 150, \n            \"Slow\": 300\n        },\n        \" Default Grid \": {\n            \"Very Fast\": 0, \n            \"Fast\": 0, \n            \"Normal\": 0, \n            \"Slow\": 0\n        }\n    }\n}\n\nconst mazeGenerationReducer = (state = init_state , action) => {\n    return state \n}\n\nexport default mazeGenerationReducer","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nimport {createStore} from 'redux'\nimport {Provider} from 'react-redux'\n\nimport mazeGeneratorReducer from './reducer/mazeGeneratorReducer'\n\nlet store = createStore(              //==> take reducer\n  mazeGeneratorReducer,\n  window._REDUX_DEVTOOLS_EXTENSION_ && window._REDUX_DEVTOOLS_EXTENSION_()\n)\n\nReactDOM.render(\n  <Provider store = {store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}