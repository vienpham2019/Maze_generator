{"version":3,"sources":["Algorithms/solve_maze/breadth_first_search.js","Algorithms/solve_maze/depth_first_search.js","Algorithms/solve_maze/a_star.js","Algorithms/solve_maze/greedy_best_first_search.js","Algorithms/solve_maze/dijkstra.js","Algorithms/solve_maze/bidirectional_dijkstra.js","Algorithms/solve_maze/bidirectional_a_star.js","Algorithms/self_solve.js","Algorithms/draw_maze/recursive_division_maze_generation.js","Algorithms/draw_maze/prims_maze_generation.js","Algorithms/draw_maze/depth_first_search_maze_generation.js","Algorithms/mazeController.js","Algorithms/helper_method.js","Algorithms/solve_maze/helper_method/algorithms_helper_method.js","App.js","reducer/mazeGeneratorReducer.js","index.js"],"names":["c","canvas","size","nodes","default_nodes","start_node","end_node","speed","visited_nodes","quere","current_node","finish_path","myReq","stack","open_list","close_list","close_list_1","close_list_2","open_list_1","current_node_1","open_list_2","current_node_2","finish_search","current_path","find_path","delay","cols","rows","frame_per_second","neighbors_node","visited_neighbors_node","current_neighbor_node","myReqDraw","block","width","height","select_draw_algorithims","start_location","end_location","Node","x","y","walls","neighbor_node","prev_node","this","grid","draw","color","beginPath","moveTo","lineTo","lineWidth","lineCap","strokeStyle","stroke","every","e","rect","fillStyle","fill","Block","g","h","f","distance","Infinity","rect_size","r","arcTo","closePath","Stack","items","count","keys","key","val","push","pop","Object","values","filter","k","index","get_top_right_bottom_left","node","array","top","find","n","right","bottom","left","stop_breadth_first_search","clearTimeout","run_solve_maze","setTimeout","clearRect","solve_maze","quere_nodes","slice","shift","check_neighbor_node","current_find_node","c_n","add_node","wall_num","has","new_block","stop_depth_first_search","v_node","peek","stop_a_star","length","remove_index","i","splice","find_child_node","node_in_open","n_g","update_node","new_node","set_node","x_1","y_1","x_2","y_2","Math","abs","parent","stop_greedy_best_first_search","sort","a","b","stop_dijkstra","create_new_node","find_distance","stop_bidirectional_dijkstra","print_close_and_open_list","find_current_node","list","list_num","c_node","close_color","open_color","open_node","close_node","next_close_list","neighbor_close_list","check_for_mix_node","stop_bidirectional_a_star","target_node","target_close_list","stop_self_solve","window","removeEventListener","set_up","addEventListener","find_next_step","path","star_size","draw_finish_path","requestAnimationFrame","cancelAnimationFrame","wall_number","draw_maze","nodes_array","x_max","y_max","x_min","y_min","random_x","getRandom","random_y","x_or_y","neightbor_node","min","max","floor","random","setup_prims_maze","w","midd_x","midd_y","center_node","draw_prims_maze","clearInterval","add_neighbor_node","create_neighbor_node","delete","link_node_with_random_neighbor","random_num","random_neighbor","get_index","move_block","neighbor_nodes","next_node","unshift","left_right","up_down","setUp","props","create_node","draw_divide_maze","myTimeOut","not_walls","store","j","depth_first_search_maze","prims_maze","draw_delay","recursive_dividion_maze","check_recursive_delay","algorithms","clear_path","depth_first_search","breadth_first_search","dijkstra","greedy_best_first_search","bidirectional_a_star","bidirectional_dijkstra","self_solve","update_info","set_walls","Array","select_start","select_end","select_wall","display_points","add_event","App","run_set_point","refs","maze","state","innerWidth","innerHeight","offsetLeft","offsetTop","setState","pageX","pageY","value","dispay_draw_button","updateCanvas","generate_speed","getContext","swal","button","content","className","select_solve_algorithims","speeds","solve_speed","solve_maze_algorithims","draw_maze_algorithims","start_x","start_y","end_x","end_y","class","style","minWidth","onChange","target","map","algorithm","selected","for","s","type","placeholder","onClick","position","backgroundColor","ref","Component","connect","init_state","mazeGenerationReducer","createStore","mazeGeneratorReducer","_REDUX_DEVTOOLS_EXTENSION_","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.3fb7ab9d.chunk.js","sourcesContent":["import {Block , Stack} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size , nodes, default_nodes , start_node , end_node , speed \n    \nlet visited_nodes ,  quere , current_node , finish_path , myReq\n\nconst breadth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    visited_nodes = new Stack()\n    nodes = props.nodes \n    default_nodes = props.default_nodes\n\n    quere = []\n    finish_path = false \n    current_node = null  \n    start_node = props.start_node\n    end_node = props.end_node\n\n    end_node.prev_node = null\n\n    speed = props.speed \n\n    quere.push(start_node)\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_breadth_first_search = () => {\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    // myReq = requestAnimationFrame(run_solve_maze)\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n    for(let node of nodes){\n        node.draw()\n    }\n\n    for(let v_node of visited_nodes.values()){\n        v_node.draw()\n    }\n\n    if(end_node.prev_node && !finish_path){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path()\n    }\n    \n    if(finish_path){\n        // cancelAnimationFrame(myReq)\n        clearTimeout(myReq)\n    }\n    if(!end_node.prev_node && !finish_path){\n        solve_maze()\n    }\n}\n  \nconst solve_maze = () => {\n    let quere_nodes = quere.slice()\n    quere.shift()\n    // visited_nodes_for_path.push(current_node)\n    if(end_node.prev_node){\n        return\n    }\n    for(let node of quere_nodes){\n        check_neighbor_node(node)\n    }\n}\n  \nconst check_neighbor_node = (node) => {\n    let current_find_node = nodes.find(c_n => c_n.x === node.x && c_n.y === node.y )\n    let { top , right , bottom , left } = get_top_right_bottom_left(node , nodes , size)\n    // top \n    add_node(top , node , 0 , current_find_node)\n\n    // right\n    add_node(right , node , 1 , current_find_node)\n\n    // bottom\n    add_node(bottom , node , 2 , current_find_node)\n\n    // left \n    add_node(left , node , 3 , current_find_node)\n}\n\nconst add_node = (neighbor_node , node , wall_num , current_find_node) => {\n    let color = 'MediumBlue' \n    if(\n        neighbor_node \n        && !current_find_node.walls[wall_num] \n        && !visited_nodes.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n        ){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = node \n            current_node = node \n        }else{\n            let new_block = new Block(x, y , c , size , color, node)\n            quere.push(new_block)\n            visited_nodes.push(`${new_block.x} , ${new_block.y}` , new_block)\n        }\n    }\n    return \n}\n  \nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n    }\n    current_node = current_node.prev_node\n}\n\nexport { breadth_first_search ,  stop_breadth_first_search}\n\n","import {Block , Stack} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet c , canvas , size ,  nodes, default_nodes , start_node , end_node , speed\n    \nlet visited_nodes , stack , current_node ,  finish_path , myReq\n\nconst depth_first_search = (props) => {\n    c = props.c\n    canvas = props.canvas \n    size = props.size \n    nodes = props.nodes \n    default_nodes = props.default_nodes\n\n    finish_path = false  \n    start_node = props.start_node\n    end_node = props.end_node\n    speed = props.speed\n\n    end_node.prev_node = null\n\n    stack = new Stack()\n    visited_nodes = new Stack()\n    visited_nodes.push(`${start_node.x} , ${start_node.y}` , start_node)\n    current_node = start_node \n\n    stack.push(`${start_node.x} , ${start_node.y}` , start_node)\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_depth_first_search = () => {\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    // myReq = requestAnimationFrame(run_solve_maze)\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes){\n        node.draw()\n    }\n\n    for(let v_node of visited_nodes.values()){\n        if(!end_node.prev_node){\n            v_node.color = 'MediumBlue' \n        }\n        v_node.draw()\n    }\n\n    if(!end_node.prev_node){\n        for(let node of stack.values()){\n            node.color = 'LightSkyBlue' \n            node.draw()\n        }\n    }\n\n    if(stack.count > 0 && !end_node.prev_node){\n        current_node = stack.peek()\n        if(!check_neighbor_node()){\n            stack.pop()\n        }\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        // cancelAnimationFrame(myReq)\n        clearTimeout(myReq)\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(current_node.x === start_node.x && current_node.y === start_node.y){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n}\n\nconst check_neighbor_node = () => {\n    let {x , y} = current_node // block \n    // let color = \"MidnightBlue\"\n    let current_find_node = nodes.find(c_n => c_n.x === x && c_n.y === y )\n    let {top , right , bottom , left } = get_top_right_bottom_left(current_node , nodes , size)\n\n    // bottom\n    if(add_node(bottom , current_find_node , 2)) return true \n\n    // right\n    if(add_node(right , current_find_node , 1)) return true \n\n    // top \n    if(add_node(top , current_find_node , 0)) return true \n\n    // left \n    if(add_node(left , current_find_node , 3)) return true \n\n    return false \n}\n\nconst add_node = (neighbor_node , current_find_node , wall_num) => {\n    let color = 'MediumBlue'\n    if(\n        neighbor_node \n        && !current_find_node.walls[wall_num] \n        && !visited_nodes.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        if(x === end_node.x && y === end_node.y){\n            end_node.prev_node = current_node\n        }else{\n            let new_block = new Block(x, y, c , size ,color , current_node)\n            stack.push(`${new_block.x} , ${new_block.y}` , new_block)\n            visited_nodes.push(`${new_block.x} , ${new_block.y}` , new_block)\n        }\n        return true \n    }\n    return false \n}\n\nexport { depth_first_search ,  stop_depth_first_search}","import { Block , Stack } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed \n\nlet open_list , close_list , current_node , myReq\n\nconst a_star = props => {\n    start_node   = props.start_node \n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed\n\n    end_node.prev_node = null\n\n    open_list = [start_node]\n    close_list = new Stack()\n    current_node = null \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_a_star = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes) {\n        node.draw('silver')\n    }\n\n    for(let node of nodes){\n        node.draw()\n    }\n\n    for(let node of close_list.values()){\n        if(!end_node.prev_node){\n            node.color = 'MediumBlue'\n        }\n        node.draw()\n    }\n\n    for(let node of open_list){\n        node.color = 'LightSkyBlue'\n        node.draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        let remove_index = 0 \n        current_node = open_list[0]\n        for(let i = 0 ; i < open_list.length ; i ++){\n            if(open_list[i].f < current_node.f) {\n                current_node = open_list[i] \n                remove_index = i \n            }\n        }\n        open_list.splice(remove_index , 1)\n\n        close_list.push(`${current_node.x} , ${current_node.y}` , current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node && current_node){\n        current_node.color = \"SpringGreen\"\n        current_node.draw()\n        current_node = current_node.prev_node\n    }\n\n    if(!current_node){\n        clearTimeout(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    // left (x - size , y )\n    add_node(left , 1)\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&  !close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        let n_g = current_node.g + size\n\n        if(node_in_open){\n            if(node_in_open.g > n_g) update_node(node_in_open, n_g , current_node ) \n        }else{\n            let new_node = set_node(neighbor_node, n_g)\n            open_list.push(new_node)\n        }\n    }\n}\n\nconst set_node = (node, g) => {\n    let color = 'MediumBlue'\n    let [x_1 , y_1] = [node.x , node.y] \n    let [x_2 , y_2] = [end_node.x , end_node.y] \n    let h = Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)\n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {a_star , stop_a_star}","import { Block , Stack} from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst greedy_best_first_search = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed\n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = new Stack()\n    current_node = null \n    finish_path = false \n\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_greedy_best_first_search = () => {\n    // cancelAnimationFrame(myReq)\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    // myReq = requestAnimationFrame(run_solve_maze)\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n    \n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n\n    for(let node of nodes){\n        node.draw()\n    }\n\n    for(let node of close_list.values()){\n        if(!end_node.prev_node){\n            node.color = 'MediumBlue'\n        }\n        node.draw()\n    }\n\n    for(let node of open_list){\n        node.color = 'LightSkyBlue' \n        node.draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        // h is the distance between current node to end node \n        current_node = open_list.sort((a,b) => a.h - b.h)[0] \n        close_list.push(`${current_node.x} , ${current_node.y}` , current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n    if(finish_path){\n        // cancelAnimationFrame(myReq)\n        clearTimeout(myReq)\n    }\n}\n\nconst find_child_node = () => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n    open_list = open_list.filter(node => node.x === current_node.x && node.y === current_node.y ? false : true )\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        if(!node_in_open) open_list.push(set_node(neighbor_node))\n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst set_node = (node) => {\n    let color = 'MediumBlue'\n    let [x_1 , y_1] = [node.x , node.y]\n    let [x_2 , y_2] = [end_node.x , end_node.y]   \n    let h = (Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2)) * size\n    let new_node = new Block(x_1 , y_1 , c , size , color , current_node , null , h )\n    return new_node \n}\n\nexport {greedy_best_first_search , stop_greedy_best_first_search}\n\n","import { Block , Stack} from '../helper_method'\n\nimport {get_top_right_bottom_left } from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes, c , canvas , size , speed \n\nlet open_list , close_list , current_node , myReq , finish_path\n\nconst dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed \n\n    end_node.prev_node = null\n    \n    open_list = [start_node]\n    close_list = new Stack()\n    current_node = null \n    finish_path = false \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_dijkstra = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes){\n        node.draw()\n    }\n\n    for(let node of close_list.values()){\n        if(!end_node.prev_node){\n            node.color = 'MediumBlue'\n        }\n        node.draw()\n    }\n\n    for(let node of open_list){\n        if(!end_node.prev_node){\n            node.color = 'LightSkyBlue' \n        }\n        node.draw()\n    }\n\n    if(current_node && end_node.x === current_node.x && end_node.y === current_node.y){\n        end_node.prev_node = current_node.prev_node\n    }\n\n    if(open_list.length > 0 && !end_node.prev_node){\n        let remove_index = 0 \n        current_node = open_list[0]\n        for(let i = 0 ; i < open_list.length ; i ++){\n            if(open_list[i].distance < current_node.distance) {\n                current_node = open_list[i] \n                remove_index = i \n            }\n        }\n        open_list.splice(remove_index , 1)\n\n        close_list.push(`${current_node.x} , ${current_node.y}` , current_node)\n        find_child_node()\n    }\n\n    if(end_node.prev_node){\n        end_node.color = \"SpringGreen\"\n        end_node.draw()\n        find_path() \n    }\n\n    if(finish_path){\n        clearTimeout(myReq)\n    }\n}\n\nconst find_child_node = () => {\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(right , 3)\n\n    // top (x , y - size)\n    add_node(top , 2)\n\n    // left (x - size , y )\n    add_node(left , 1)\n\n    // bottom (x , y + size)\n    add_node(bottom , 0)\n\n}\n\nconst add_node = (neighbor_node , wall_num) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(node_in_open){\n            update_node(node_in_open)\n        }else{\n            let new_node = create_new_node(neighbor_node)\n            open_list.push(new_node)\n        }\n            \n    }\n}\n\nconst find_path = () => {\n    current_node.color = \"SpringGreen\"\n    if(!current_node.prev_node){\n        start_node.color = \"SpringGreen\"\n        start_node.draw()\n        finish_path = true\n        return\n    }\n    current_node = current_node.prev_node\n    return \n}\n\nconst create_new_node = (node) => {\n    let distance = find_distance(node)\n    return new Block(node.x , node.y , c , size , 'MediumBlue' , current_node , null , null , null , distance)\n}\n\nconst find_distance = (node) => {\n    // find distance from current node to next node \n    let [x_1 , y_1] = [current_node.x , current_node.y ]\n\n    let [x_2 , y_2] = [node.x , node.y]\n\n   return Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2) + current_node.distance\n}\n\nconst update_node = node => {\n    if(current_node.distance + size < node.distance){\n        node.distance = find_distance(node)\n    }\n}\n\nexport {dijkstra , stop_dijkstra}","import { Block , Stack } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed  \n\nlet close_list_1 , close_list_2 , open_list_1 , current_node_1 , open_list_2, current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_dijkstra = props => {\n    start_node = props.start_node\n    start_node.distance = 0\n    \n    end_node = props.end_node \n    end_node.distance = 0\n\n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed \n    \n    open_list_1 = [start_node]\n    close_list_1 = new Stack()\n\n    open_list_2 = [end_node]\n    close_list_2 = new Stack()\n\n    current_node_1 = start_node\n    current_node_2 = end_node \n\n    finish_path = false \n    finish_search = false \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_dijkstra = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n\n    for(let node of nodes){\n        node.draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_2.length > 0 && !finish_search){\n        find_current_node(open_list_2 , 2)\n        close_list_2.push(`${current_node_2.x} , ${current_node_2.y}` , current_node_2)\n        open_list_2 = find_child_node(current_node_2 , open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(open_list_1.length > 0 && !finish_search){\n        find_current_node(open_list_1 , 1)\n        close_list_1.push(`${current_node_1.x} , ${current_node_1.y}` , current_node_1)\n        open_list_1 = find_child_node(current_node_1 , open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2){\n            finish_path = true\n        }\n\n        find_path() \n    }\n\n    if(finish_path){\n        // cancelAnimationFrame(myReq)\n        clearTimeout(myReq)\n    }\n}\n\nconst find_current_node = (list , list_num) => {\n    let c_node = list[0]\n    let remove_index = 0 \n    for(let i = 0 ; i < list.length ; i ++){\n        if(list[i].distance < c_node.distance){\n            c_node = list[i]\n            remove_index = i \n        }\n    }\n    list.splice(remove_index , 1)\n    if(list_num === 1){\n        open_list_1 = list \n        current_node_1 = c_node \n    }else{\n        open_list_2 = list \n        current_node_2 = c_node \n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color ) => {\n    if(!finish_search){\n        for(let open_node of open_list){\n            open_node.color = open_color\n            open_node.draw()\n        }\n    }\n\n    for(let close_node of close_list.values()){\n        if(!finish_search){\n            close_node.color = close_color \n        }\n        close_node.draw()\n    }\n}\n\nconst check_for_mix_node = (next_close_list , x , y) => {\n    let node = next_close_list.has(`${x} , ${y}`)\n    if(node){\n        finish_search = true \n        if(close_list_1.has(`${x} , ${y}`)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , open_list , close_list , next_close_list) => {\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // Right (x + size , y)\n    add_node(right , c_node , 3 , close_list , open_list , next_close_list) // 3\n\n    // top (x , y - size)\n    add_node(top , c_node , 2 , close_list , open_list , next_close_list) // 2\n\n    // left (x - size , y )\n    add_node(left , c_node , 1 , close_list , open_list , next_close_list) // 1\n\n    // bottom (x , y + size)\n    add_node(bottom , c_node , 0 , close_list , open_list , next_close_list) // 0\n\n    return open_list\n}\n\nconst add_node = (neighbor_node , c_node , wall_num , close_list , open_list , neighbor_close_list) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        &&!close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n        ){\n        let {x , y} = neighbor_node\n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        \n        if(!check_for_mix_node(neighbor_close_list , x , y)){\n            if(node_in_open){\n                update_node(node_in_open , c_node) \n            } else{\n                let new_node = create_new_node(neighbor_node , c_node)\n                // open_list = add_to_heap(new_node , open_list , (a,b) => a.distance < b.distance)\n                open_list.push(new_node)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst create_new_node = (node , c_node) => {\n    let distance = find_distance(node , c_node)\n    return new Block(node.x , node.y , c , size , 'MidnightBlue' , c_node , null , null , null , distance)\n}\n\nconst find_distance = (node , c_node) => {\n    // find distance from current node to next node \n    let [ x_1 , y_1 ]= [ c_node.x , c_node.y ] \n\n    let [ x_2 , y_2 ] = [ node.x , node.y ] \n\n   return Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2) + c_node.distance\n}\n\nconst update_node = (node , c_node) => {\n    if(c_node.distance + size < node.distance){\n        node.distance = find_distance(node , c_node)\n    }\n    return node\n}\n\nexport {bidirectional_dijkstra , stop_bidirectional_dijkstra}","import { Block , Stack } from '../helper_method'\nimport {get_top_right_bottom_left} from './helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size , speed \n\nlet open_list_1 , close_list_1 , current_node_1 , open_list_2 , close_list_2 , current_node_2 , myReq , finish_path , finish_search \n\nconst bidirectional_a_star = props => {\n    start_node = props.start_node\n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    speed = props.speed \n\n    open_list_1 = [start_node]\n    close_list_1 = new Stack()\n\n    open_list_2 = [end_node]\n    close_list_2 = new Stack()\n\n    current_node_1 = null \n    current_node_2 = null \n\n    finish_path = false \n    finish_search = false \n\n    clearTimeout(myReq)\n    run_solve_maze()\n}\n\nconst stop_bidirectional_a_star = () => {\n    clearTimeout(myReq)\n}\n\nconst run_solve_maze = () => {\n    myReq = setTimeout(() => {\n        run_solve_maze()\n    }, speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n    \n    for(let node of default_nodes) {\n        node.draw('silver')\n    }\n\n    for(let node of nodes ){\n        node.draw()\n    }\n\n    print_close_and_open_list(close_list_1 , open_list_1 , 'MediumBlue' , 'LightSkyBlue' )\n    print_close_and_open_list(close_list_2 , open_list_2 , 'CadetBlue' , 'LightCyan')\n\n    if(open_list_1.length > 0 && !finish_search){\n        find_current_node(open_list_1 , 1)\n\n        close_list_1.push(`${current_node_1.x} , ${current_node_1.y}` , current_node_1)\n        open_list_1 = find_child_node(current_node_1 , end_node, open_list_1 , close_list_1 , close_list_2)\n    }\n\n    if(open_list_2.length > 0 && !finish_search){\n        find_current_node(open_list_2 , 2)\n\n        close_list_2.push(`${current_node_2.x} , ${current_node_2.y}` , current_node_2)\n        open_list_2 = find_child_node(current_node_2 , start_node, open_list_2 , close_list_2 , close_list_1)\n    }\n\n    if(finish_search){\n        start_node.draw()\n        end_node.draw()\n\n        if(!current_node_1 && !current_node_2) finish_path = true\n        find_path() \n    }\n\n    if(finish_path){\n        clearTimeout(myReq)\n    }\n}\n\nconst find_current_node = (list , list_num) => {\n    let c_node = list[0]\n    let remove_index = 0 \n    for(let i = 0 ; i < list.length ; i ++){\n        if(list[i].f < c_node.f){\n            c_node = list[i]\n            remove_index = i \n        }\n    }\n    list.splice(remove_index , 1)\n    if(list_num === 1){\n        open_list_1 = list \n        current_node_1 = c_node \n    }else{\n        open_list_2 = list \n        current_node_2 = c_node \n    }\n}\n\nconst print_close_and_open_list = (close_list , open_list , close_color , open_color) => {\n    if(!finish_search){\n        for(let open_node of open_list){\n            open_node.color = open_color\n            open_node.draw()\n        }\n    }\n\n    for(let close_node of close_list.values()){\n        if(!finish_search) close_node.color = close_color \n        close_node.draw()\n    }\n}\n\nconst check_for_mix_node = (target_close_list , x , y) => {\n    let node = target_close_list.has(`${x} , ${y}`)\n    if(node){\n        finish_search = true \n        if(close_list_1.has(`${x} , ${y}`)){\n            current_node_1 = node\n        }else{\n            current_node_2 = node\n        }\n        return true \n    }\n    return false \n}\n\nconst find_child_node = (c_node , target_node , open_list , close_list , target_close_list) => {\n\n    let {top , right , bottom , left} = get_top_right_bottom_left(c_node , nodes , size)\n\n    // right (x + size , y)\n    add_node(c_node , right , 3 , close_list , open_list , target_close_list , target_node)\n\n    // top (x , y - size)\n    add_node(c_node , top , 2 , close_list , open_list , target_close_list , target_node)\n\n    // left (x - size , y )\n    add_node(c_node , left , 1 , close_list , open_list , target_close_list , target_node)\n\n    // bottom (x , y + size)\n    add_node(c_node , bottom , 0 , close_list , open_list , target_close_list , target_node)\n\n    return open_list\n}\n\nconst add_node = (c_node , neighbor_node , wall_num , close_list , open_list , target_close_list , target_node) => {\n    if(\n        neighbor_node \n        && !neighbor_node.walls[wall_num] \n        && !close_list.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        let {x , y} = neighbor_node \n        let node_in_open = open_list.find(n => n.x === x  && n.y === y)\n        let n_g = c_node.g + size\n\n        if(!check_for_mix_node(target_close_list , x , y)){\n            if(node_in_open){ \n                if(n_g < node_in_open.g) update_node(node_in_open, n_g , c_node )\n            }else{\n                let new_node = set_node(neighbor_node , n_g , c_node , target_node)\n                open_list.push(new_node)\n            }\n        }\n    }\n    return open_list\n}\n\nconst find_path = () => {\n    let color = \"SpringGreen\"\n    if(current_node_1){\n        current_node_1.color = color\n        current_node_1 = current_node_1.prev_node\n    }\n    if(current_node_2){\n        current_node_2.color = color\n        current_node_2 = current_node_2.prev_node \n    }\n}\n\nconst set_node = (node, g , c_node , target_node) => {\n    let color = \"MediumBlue\"\n    let [x_1 , y_1] = [node.x , node.y] \n    let [x_2 , y_2] = [target_node.x , target_node.y]  \n    let h = Math.abs(x_1 - x_2) + Math.abs(y_1 - y_2) \n    let f = h + g \n    let new_node = new Block(x_1 , y_1 , c , size , color , c_node , g , h , f)\n    return new_node \n}\n\nconst update_node = (node , g , parent) => {\n    node.g = g \n    node.f = g + node.h \n    node.parent = parent \n}\n\nexport {bidirectional_a_star , stop_bidirectional_a_star}","import { Block , Stack} from './helper_method'\nimport {get_top_right_bottom_left} from './solve_maze/helper_method/algorithms_helper_method'\n\nlet start_node , end_node , nodes , default_nodes , c , canvas , size \n\nlet current_node , current_path , myReq , find_path \n\nconst self_solve = props => {\n    start_node = props.start_node\n    current_node = start_node \n    end_node = props.end_node \n    nodes = props.nodes\n    default_nodes = props.default_nodes\n    c = props.c \n    canvas = props.canvas \n    size = props.size \n    find_path = false \n\n    current_path = new Stack()\n    current_path.push(`${current_node.x} , ${current_node.y}` , set_node(current_node))\n    set_up()\n}\n\nconst stop_self_solve = () => {\n    window.removeEventListener(\"keydown\" , run_solve_maze)\n}\n\nconst set_up = () => {\n    c.clearRect(0,0,canvas.width, canvas.height)\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n    for(let node of nodes){\n        node.draw()\n    }\n    stop_self_solve()\n    window.addEventListener(\"keydown\" , run_solve_maze)\n}\n\nconst run_solve_maze = e => {\n        c.clearRect(0,0,canvas.width, canvas.height)\n        current_node = current_path.peek()\n        let {top , right , bottom , left} = get_top_right_bottom_left(current_node , nodes , size)\n        switch (e.key) {\n            case \"a\":\n                find_next_step(left , 1)\n                break \n            case \"w\":\n                find_next_step(top , 2)\n                break \n            case \"d\":\n                find_next_step(right , 3)\n                break \n            case \"s\":\n                find_next_step(bottom , 0)\n                break \n        }\n        for(let node of default_nodes){\n            node.draw('silver')\n        }\n        for(let node of nodes){\n            node.draw()\n        }\n        for(let path of current_path.values()){\n            path.star_size = size \n            path.color = \"MediumBlue\"\n            current_path.peek().color = \"LightSkyBlue\"\n            path.draw()\n        }\n        if(find_path) {\n            stop_self_solve()\n            current_node = current_path.peek()\n            draw_finish_path()\n        }\n}\n\nconst draw_finish_path = () => {\n    myReq = requestAnimationFrame(draw_finish_path)\n    current_node.color = \"SpringGreen\"\n    current_node.draw()\n    current_node = current_node.prev_node\n\n    if(!current_node) cancelAnimationFrame(myReq)\n}\n\nconst find_next_step = (node , wall_number) => {\n    if(node && !node.walls[wall_number]){\n        let {x , y} = node \n        let key = '' + x + y \n        if(end_node.x === x && end_node.y === y) find_path = true \n        if(!current_path.has(key)){\n            current_path.push(key , set_node(node))\n        }else{\n            current_path.pop()\n        }\n    }\n\n}\n\nconst set_node = (node) => {\n    let color = \"MediumBlue\"\n    let {x , y} = node \n    let new_node = new Block(x, y , c , size , color , current_path.peek())\n    return new_node \n}\n\nexport {self_solve , stop_self_solve}","let delay , speed , size , cols , rows , nodes\n\nconst recursive_dividion_maze = (props) => {\n    delay = props.delay\n    speed = props.speed \n    size = props.size \n    cols = props.cols \n    rows = props.rows\n    nodes = props.nodes\n\n    return draw_maze(nodes , cols , rows , 0, 0 , delay , speed , size)\n}\n\nconst draw_maze = (nodes_array , x_max, y_max, x_min , y_min) => {\n\n    if(x_max - x_min < 1 || y_max - y_min < 1) return\n  \n    let random_x = getRandom(x_min,x_max)\n    let random_y = getRandom(y_min,y_max)\n    let x_or_y = getRandom(-20, 20) \n  \n    delay ++\n  \n    setTimeout(() => {\n      for(let node of nodes_array){\n          if(x_or_y > 0) { // x\n              if (\n                  node.x === random_x * size + (size / 2) \n                  && node.y <= y_max * size + (size / 2)\n                  && node.y >= y_min * size + (size / 2)\n                  && node.x !== (cols - 1) * size + (size / 2)\n                  ){\n                  if (node.y !== random_y * size + (size / 2)){\n                      node.walls[1] = true\n                      let {x , y} = node\n                      let neightbor_node = nodes_array.find(node => node.x === (x + size) && node.y === y) \n                      if(neightbor_node){\n                          neightbor_node.walls[3] = true\n                      } \n                  }\n              }\n          }else{\n              if(\n                  node.y === random_y * size + (size / 2)\n                  && node.x <= x_max * size + (size / 2)\n                  && node.x >= x_min * size + (size / 2)\n                  ){\n                  if(node.x !== random_x * size + (size / 2)){\n                      node.walls[2] = true\n                      let {x , y} = node\n                      let neightbor_node = nodes_array.find(node => node.x === x && node.y === (y + size)) \n                      if(neightbor_node){\n                        neightbor_node.walls[0] = true\n                      } \n                  }\n              }\n          }\n            node.draw()\n        }\n    }, delay * speed)\n  \n    if(x_or_y > 0){ \n      draw_maze(nodes_array, random_x, y_max, x_min, y_min) // right \n      draw_maze(nodes_array, x_max, y_max, random_x + 1, y_min) // left \n    }else{\n      draw_maze(nodes_array, x_max, random_y, x_min, y_min) // top \n      draw_maze(nodes_array, x_max, y_max, x_min , random_y + 1) // bottom\n    }\n  \n    return delay \n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {recursive_dividion_maze}","import {get_top_right_bottom_left} from '../solve_maze/helper_method/algorithms_helper_method'\nimport { Stack } from '../helper_method'\n\nlet size , nodes , default_nodes , cols , rows , canvas , c , frame_per_second , speed \nlet neighbors_node , visited_neighbors_node , current_neighbor_node , myReqDraw \nconst prims_maze = props => {\n    size = props.size\n    nodes = props.nodes \n    default_nodes = props.default_nodes\n    cols = props.cols \n    rows = props.rows \n    canvas = props.canvas \n    c = props.c \n\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    neighbors_node = new Stack()\n    visited_neighbors_node = new Stack()\n    current_neighbor_node = null \n    \n    clearInterval(myReqDraw)\n    setup_prims_maze(nodes , cols , rows)\n}\n\nconst stop_prims_draw_maze = () => {\n    clearInterval(myReqDraw)\n}\n\nconst setup_prims_maze = (nodes_array , w , h) => {\n    let midd_x =  Math.floor(w / 2) * size + (size / 2)\n    let midd_y =  Math.floor(h / 2) * size + (size / 2)\n    let center_node = nodes_array.find(node => node.x === midd_x && node.y === midd_y)\n    neighbors_node.push(`${center_node.x} , ${center_node.y}` , center_node)\n    visited_neighbors_node.push(`${center_node.x} , ${center_node.y}` , center_node)\n    current_neighbor_node = center_node\n\n    draw_prims_maze()\n}\n\nconst draw_prims_maze = () => {\n    myReqDraw = setTimeout(() => {\n        draw_prims_maze()\n    }, frame_per_second / speed)\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes){\n        node.draw()\n    }\n\n    if(neighbors_node.count === 0){\n        clearInterval(myReqDraw)\n    }\n\n    add_neighbor_node()\n}\n\nconst add_neighbor_node = () => {\n    let {x , y} = current_neighbor_node\n    let {top , right , bottom , left} = get_top_right_bottom_left(current_neighbor_node , nodes , size) \n\n    // top \n    create_neighbor_node(top)\n\n    // right \n    create_neighbor_node(right)\n\n    //bottom \n    create_neighbor_node(bottom)\n\n    //left \n    create_neighbor_node(left)\n\n    neighbors_node.delete(`${x} , ${y}`)\n\n    link_node_with_random_neighbor()\n}\n\nconst create_neighbor_node = (neighbor_node) => {\n    if(\n        neighbor_node \n        && !visited_neighbors_node.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n        && !neighbors_node.has(`${neighbor_node.x} , ${neighbor_node.y}`)\n    ){\n        neighbors_node.push(`${neighbor_node.x} , ${neighbor_node.y}` , neighbor_node)\n        neighbor_node.prev_node = current_neighbor_node\n    }\n}\n\nconst link_node_with_random_neighbor = () => {\n    if(neighbors_node.count <= 0) return\n    let random_num = getRandom(0 , neighbors_node.count)\n    let random_neighbor = neighbors_node.get_index(random_num)\n    \n    let {top , right , bottom , left} = get_top_right_bottom_left(random_neighbor, visited_neighbors_node.values(), size)\n\n    if(top && top.x === random_neighbor.prev_node.x && top.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[0] = false \n        top.walls[2] = false\n    }\n\n    if(right && right.x === random_neighbor.prev_node.x && right.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[1] = false \n        right.walls[3] = false\n    }\n\n    if(bottom && bottom.x === random_neighbor.prev_node.x && bottom.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[2] = false \n        bottom.walls[0] = false\n    }\n\n    if(left && left.x === random_neighbor.prev_node.x && left.y === random_neighbor.prev_node.y){\n        random_neighbor.walls[3] = false \n        left.walls[1] = false\n    }\n    current_neighbor_node = random_neighbor\n    visited_neighbors_node.push(`${random_neighbor.x} , ${random_neighbor.y}` , random_neighbor)\n}\n\nconst getRandom = (min,max) => {\n    return Math.floor(Math.random() * (max - min) + min)\n}\n\nexport {prims_maze , stop_prims_draw_maze}\n\n","import {Block} from '../helper_method'\nlet nodes , default_nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed \n\nlet block , myReq , visited_nodes , width , height \n\nconst depth_first_search_maze = props => {\n    nodes = props.nodes \n    default_nodes = props.default_nodes\n    canvas = props.canvas \n    c = props.c \n    stack = props.stack\n    size = props.size\n    cols = props.cols \n    rows = props.rows\n    frame_per_second = props.frame_per_second\n    speed = props.speed\n\n    block = new Block(size / 2,size / 2 , c , size)\n\n    width = cols * size \n    height = rows * size  \n\n    let start_node = nodes.find(n => n.x === (size / 2) && n.y === (size / 2))\n\n    visited_nodes = [start_node]\n\n    clearInterval(myReq)\n    draw_maze()\n}\n\nconst stop_depth_first_search_draw_maze = () => {\n    clearInterval(myReq)\n}\n\nconst draw_maze = () => {\n    myReq = setTimeout(() => {\n        draw_maze()\n    }, frame_per_second / speed);\n    c.clearRect(0,0,canvas.width, canvas.height)\n\n    for(let node of default_nodes){\n        node.draw('silver')\n    }\n    \n    for(let node of nodes){\n        node.draw()\n    }\n\n    if(stack.length === 0){\n        clearInterval(myReq)\n    }else{ \n        move_block()  \n    }\n}\n\nconst move_block = () => {\n    let current_node = stack[0]\n    let neighbor_nodes = []\n    let x = current_node.x\n    let y = current_node.y\n\n    // top\n    if(y - size > 0 && !visited_nodes.find(n => n.x === x && n.y === y - size)){\n        let top = nodes.find(n => n.x === x && n.y === y - size)\n        neighbor_nodes.push(top)\n    }\n\n    // right \n    if(x + size < width && !visited_nodes.find(n => n.x === x + size && n.y === y)){\n        let right = nodes.find(n => n.x === x + size && n.y === y)\n        neighbor_nodes.push(right)\n    }\n\n    // bottom\n    if(y + size < height && !visited_nodes.find(n => n.x === x && n.y === y + size)){\n        let bottom = nodes.find(n => n.x === x && n.y === y + size)\n        neighbor_nodes.push(bottom)\n    }\n\n    // left\n    if(x - size > 0 && !visited_nodes.find(n => n.x === x - size && n.y === y)){\n        let left = nodes.find(n => n.x === x - size && n.y === y)\n        neighbor_nodes.push(left)\n    }\n\n    if(neighbor_nodes.length > 0){\n        let next_node = neighbor_nodes[Math.floor(Math.random() * neighbor_nodes.length)]\n        stack.unshift(next_node)\n        visited_nodes.push(next_node)\n        let left_right = next_node.x - current_node.x\n        let up_down = next_node.y - current_node.y\n\n        if(left_right > 0) { // right \n            current_node.walls[1] = false \n            next_node.walls[3] = false \n        }else if(left_right < 0){ // left\n            current_node.walls[3] = false \n            next_node.walls[1] = false \n        } \n\n        if(up_down > 0) { // down\n            current_node.walls[2] = false \n            next_node.walls[0] = false \n        }else if(up_down < 0){ // up\n            current_node.walls[0] = false \n            next_node.walls[2] = false \n        }\n        block.x = next_node.x \n        block.y = next_node.y\n    }else{\n        block.x = current_node.x \n        block.y = current_node.y\n        stack.shift()\n    }\n    block.draw()\n}\n\nexport {depth_first_search_maze , stop_depth_first_search_draw_maze}","import { Node , Block } from './helper_method'\nimport { breadth_first_search , stop_breadth_first_search }from './solve_maze/breadth_first_search'\nimport { depth_first_search , stop_depth_first_search }from './solve_maze/depth_first_search'\nimport { a_star , stop_a_star }from './solve_maze/a_star'\nimport { greedy_best_first_search , stop_greedy_best_first_search }from './solve_maze/greedy_best_first_search'\nimport { dijkstra , stop_dijkstra }from './solve_maze/dijkstra'\nimport { bidirectional_dijkstra , stop_bidirectional_dijkstra }from './solve_maze/bidirectional_dijkstra'\nimport { bidirectional_a_star , stop_bidirectional_a_star }from './solve_maze/bidirectional_a_star'\n\nimport {self_solve , stop_self_solve} from './self_solve'\n\nimport { recursive_dividion_maze } from './draw_maze/recursive_division_maze_generation'\nimport { prims_maze , stop_prims_draw_maze} from './draw_maze/prims_maze_generation'\nimport { depth_first_search_maze , stop_depth_first_search_draw_maze } from './draw_maze/depth_first_search_maze_generation'\n\nimport {get_top_right_bottom_left} from './solve_maze/helper_method/algorithms_helper_method'\n\nlet size , width , height , cols , rows , select_draw_algorithims , speed \n\nlet delay, canvas , c , start_node, end_node , nodes , default_nodes , stack , frame_per_second , maze_speed , myTimeOut , start_location , end_location \n\nconst setUp = (props) => {\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_bidirectional_dijkstra()\n  stop_greedy_best_first_search()\n  stop_bidirectional_a_star()\n  stop_self_solve()\n\n  stop_depth_first_search_draw_maze()\n  stop_prims_draw_maze()\n\n  c = props.c\n  canvas = props.canvas \n  stack = []\n\n  cols = props.cols \n  rows = props.rows \n  size = props.size \n  width = props.width\n  height = props.height\n  select_draw_algorithims = props.select_draw_algorithims\n\n  size = Math.floor(width / cols)\n\n  start_location = {x: size / 2 , y: size / 2}\n  end_location = {x: (cols - 1) * size + (size / 2) , y: (rows - 1) * size + (size / 2)}\n\n  delay = 0 \n  speed = props.speed\n  maze_speed = 700\n\n  frame_per_second = 1000\n\n  canvas.width = width\n  canvas.height = height\n\n  nodes = create_node(\n        select_draw_algorithims === \"Recursive Division\" \n    ||  select_draw_algorithims === \" Default Grid \"\n  )\n  default_nodes = create_node(false)\n  draw_divide_maze(props)\n  clearTimeout(myTimeOut)\n  return nodes\n}\n\nconst create_node = (not_walls) => {\n  let store = []\n  for(let i = 0; i < rows ; i ++){\n    for(let j = 0; j < cols ; j ++){\n      let walls = not_walls\n        ? [false , false , false ,false]  \n        : [true , true , true , true]\n\n      let x = j * size + (size / 2)\n      let y = i * size + (size / 2)\n      let node = new Node(x, y , c , size , walls)\n      if(select_draw_algorithims !== \" Default Grid \"){\n        if(i === 0){\n          node.walls[0] = true\n        }else if(i === rows - 1){\n          node.walls[2] = true\n        }\n\n        if(j === 0){\n          node.walls[3] = true\n        }else if(j === cols - 1){\n          node.walls[1] = true\n        }\n\n        if(i === 0 && j === 0) {\n            node.walls[0] = false \n        }\n        if(j === cols - 1 && i === rows - 1){\n          node.walls[1] = false\n        }\n\n        if(i === 0 && j === 0){\n            stack.push(node)\n        }\n      }\n      store.push(node)\n    }\n  }\n  return store\n}\n\nconst draw_divide_maze = (props) => {\n\n  start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n\n  for(let node of default_nodes){\n    node.draw('silver')\n  }\n\n  switch (select_draw_algorithims) {\n    case \"Depth first search\":\n      depth_first_search_maze({nodes , default_nodes , canvas , c , stack , size , cols , rows , frame_per_second , speed })\n      break\n    case \"Prim's\": \n      prims_maze({size , nodes , default_nodes , cols , rows , canvas , c , frame_per_second , speed})\n      break \n    case \"Recursive Division\": \n      let draw_delay = recursive_dividion_maze({delay , speed , size , cols , rows , nodes})\n      if(draw_delay){\n        setTimeout(() => {\n            props.check_recursive_delay(true)\n          }, draw_delay * speed);\n        }\n      break \n  }\n\n}\n\nconst run_solve_maze = (algorithms , speed) => {\n  clear_path()\n\n  switch (algorithms) {\n    case \"A star\":\n      a_star({start_node , end_node , nodes , default_nodes , c , canvas , size , speed})\n      break\n    case \"Depth first search\": \n      depth_first_search({nodes , default_nodes , start_node , end_node , c , canvas , size , speed})\n      break\n    case \"Breadth first search\": \n      breadth_first_search({c , canvas , size , nodes , default_nodes , start_node , end_node , speed})\n      break \n    case \"Dijkstra's\": \n      dijkstra({start_node , end_node , nodes, default_nodes , c , canvas , size , speed})\n      break \n    case \"Greedy best first search\": \n      greedy_best_first_search({start_node , end_node , nodes , default_nodes , c , canvas , size , speed})\n      break \n    case \"Bidirectional a star\": \n      bidirectional_a_star({start_node , end_node , nodes , default_nodes , c , canvas , size , speed})\n      break \n    case \"Bidirectional dijkstra's\": \n      bidirectional_dijkstra({start_node , end_node , nodes, default_nodes , c , canvas , size , speed})\n      break \n    default: \n      self_solve({nodes , default_nodes , start_node , end_node , c , canvas , size})\n      break \n  }\n}\n\nconst update_info = props => {\n  if(props.start_location){\n    start_location = props.start_location\n    start_node = new Block(start_location.x , start_location.y , c , size , \"blue\")\n  }\n\n  if(props.end_location){\n    end_location = props.end_location\n    end_node = new Block(end_location.x , end_location.y , c , size , \"green\" )\n  }\n\n  if(props.set_walls){\n    c.clearRect(0,0,canvas.width, canvas.height)\n    clear_path()\n    let {x , y} = props.set_walls\n    for(let node of default_nodes) {\n      node.draw('silver')\n    }\n\n    for(let node of nodes) {\n      if(node.x === x && node.y === y){\n        node.walls = new Array(4).fill(!node.walls[0])\n      }\n      node.draw()\n    }\n  }\n}\n\nconst clear_path = () => {\n  stop_greedy_best_first_search()\n  stop_a_star()\n  stop_dijkstra()\n  stop_breadth_first_search()\n  stop_depth_first_search()\n  stop_bidirectional_dijkstra()\n  stop_bidirectional_a_star()\n\n  stop_self_solve()\n}\n\nexport {setUp , run_solve_maze , update_info}\n","\n\nconst Node = function(x , y , c , size , walls , neighbor_node = [], prev_node = null){\n    this.x = x\n    this.y = y\n    this.neighbor_node = neighbor_node\n    this.prev_node = prev_node \n    this.walls = walls// [top, right , bottom , left ]\n    this.grid = false \n\n    this.draw = (color = \"black\") => {\n        let x = this.x - (size / 2)\n        let y = this.y - (size / 2)\n        // Top \n        if(this.walls[0]){\n            c.beginPath()\n            c.moveTo(x, y)\n            c.lineTo(x + size , y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // right\n        if(this.walls[1]){\n            c.beginPath()\n            c.moveTo(x + size, y)\n            c.lineTo(x + size , y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // bottom\n        if(this.walls[2]){\n            c.beginPath()\n            c.moveTo(x + size, y + size)\n            c.lineTo(x, y +size)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        // left \n        if(this.walls[3]){\n            c.beginPath()\n            c.moveTo(x, y + size)\n            c.lineTo(x, y)\n            c.lineWidth = 4\n            c.lineCap = \"round\"\n            c.strokeStyle = color\n            c.stroke()\n        }\n\n        if(this.walls.every( e => e === true) && this.grid){\n            c.beginPath()\n            c.rect(x, y, size, size)\n            c.fillStyle = 'black'\n            c.fill()\n        }\n    }\n}\n\nconst Block = function(x , y , c , size, color = \"red\", prev_node = null , g = null , h = null , f = null , distance = Infinity){\n    this.x = x \n    this.y = y \n    this.prev_node = prev_node\n    this.color = color\n    this.g = g \n    this.h = h \n    this.f = f\n    this.c = c \n    this.distance = distance\n    this.size = size \n  \n    this.draw = () => {\n        let x = this.x - (this.size / 3) \n        let y = this.y - (this.size / 3)\n        let rect_size = this.size * 2/3\n        let r = rect_size * 1/4\n        this.c.beginPath()\n        this.c.moveTo(x+r, y)\n        this.c.arcTo(x+rect_size, y,   x+rect_size, y+rect_size, r)\n        this.c.arcTo(x+rect_size, y+rect_size, x,   y+rect_size, r)\n        this.c.arcTo(x,   y+rect_size, x,   y,   r)\n        this.c.arcTo(x,   y,   x+rect_size, y,   r)\n        this.c.fillStyle = this.color\n        this.c.fill()\n        // this.c.fillStyle = 'black'\n        // this.c.fillText(this.f , x , y)\n        // this.c.fillText(this.h , x + 10 , y + 10)\n        // this.c.fillText(this.g , x + 20 , y + 20)\n        this.c.closePath()\n    }\n}\n\nclass Stack {\n    constructor() {\n      this.items = {};\n      this.count = 0;\n      this.keys = []\n    }\n    \n    getLength() {\n      return this.count;\n    }\n    \n    push(key , val) {\n        this.items[key] = val; \n        this.count += 1;\n        this.keys.push(key) \n    }\n    \n    pop() {\n      if(this.count > 0) {\n        delete this.items[this.keys[--this.count]]\n        this.keys.pop()\n      }\n    }\n    \n    peek() {\n      return this.items[this.keys[this.count - 1]];\n    }\n\n    has(key){\n        return this.items[key]\n    }\n\n    values(){\n        return Object.values(this.items)\n    }\n\n    delete(key){\n        delete this.items[key]\n        this.count-- \n        this.keys = this.keys.filter(k => k !== key )\n    }\n\n    get_index(index){\n        return this.items[this.keys[index]]\n    }\n\n    size(){\n        return this.count\n    }\n}\n\nexport {Node , Block , Stack}","const get_top_right_bottom_left = (node , array , size) => {\n    if(!node) return null\n    let {x , y} = node\n    let top = array.find(n => n.x === x && n.y === y - size)\n    let right = array.find(n => n.x === x + size && n.y === y)\n    let bottom = array.find(n => n.x === x && n.y === y + size)\n    let left = array.find(n => n.x === x - size && n.y === y)\n\n    return {top , right , bottom , left }\n}\n\n\nexport {get_top_right_bottom_left}","import React , {Component} from 'react'\nimport {setUp , run_solve_maze , update_info} from './Algorithms/mazeController'\nimport {connect} from 'react-redux'\nimport swal from '@sweetalert/with-react'\n\nlet select_start = false\nlet select_end = false \nlet select_wall = false \nlet display_points = false \nlet add_event = false \n\nclass App extends Component{\n  constructor(){\n    super()\n    this.state = {\n      width: (window.innerWidth * .95),\n      height: (window.innerHeight * .92),\n      select_draw_algorithims: \" Default Grid \", \n      select_solve_algorithims: \"A star\",\n      rows: 15, \n      dispay_draw_button: true , \n      generate_speed: \"Normal\", \n      start_location: {x: 40 , y: 170}, \n      end_location: {x: 40 , y: 170}, \n      speeds: {\"Slow\": 200 , \"Normal\": 100 , \"Fast\": 50, \"Very Fast\": 10}, \n      solve_speed: 50 \n    }\n  }\n\n  componentDidMount(){\n    display_points = true\n    this.setState({select_draw_algorithims: \" Default Grid \"})\n    this.updateCanvas()\n    this.run_set_point()\n  }\n\n  run_set_point = () => {\n    let canvas = this.refs.maze\n    let {width , rows } = this.state \n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n    let size = Math.floor(width / cols)\n    let {offsetLeft , offsetTop} = canvas\n    let start_location = {x: offsetLeft + (size / 2) , y: offsetTop + (size / 2)}\n    let end_location = {x: offsetLeft + ((cols - 1) * size + (size / 2)) , y: offsetTop + ((rows - 1) * size + (size / 2))}\n    this.setState({start_location , end_location})\n\n    if(!add_event){\n      canvas.addEventListener('mousedown' , e => {\n        add_event = true\n\n        let {pageX , pageY} = e\n        let x = Math.floor(((pageX - offsetLeft) / size)) * (size) + (size / 2) + offsetLeft\n        let y = Math.floor(((pageY - offsetTop) / size)) * (size) + (size / 2) + offsetTop\n        if(x < (cols * size) + offsetLeft && y < (rows * size) + offsetTop){\n          if(select_end){\n            end_location = {x , y}\n            this.setState({end_location})\n            update_info({end_location: {x: x - offsetLeft ,y: y - offsetTop}})\n          }\n    \n          if(select_start){\n            start_location = {x , y}\n            this.setState({start_location})\n            update_info({start_location: {x: x - offsetLeft ,y: y - offsetTop}})\n          }\n    \n          if(select_wall){\n            update_info({set_walls: {x: x - offsetLeft ,y: y - offsetTop}})\n          }\n        }\n      })\n    }\n  }\n\n  check_recursive_delay = (value) => {\n    this.setState({dispay_draw_button: value})\n  }\n\n  updateCanvas = (select_draw_algorithims = this.state.select_draw_algorithims) => {\n    // rows == min 15 and max 50\n    let {rows , height , width } = this.state\n\n    let speed = this.props.speed[select_draw_algorithims][this.state.generate_speed]\n\n    if(select_draw_algorithims === \"Recursive Division\"){\n      this.check_recursive_delay(false)\n    }\n\n    let cols = Math.floor(rows * ((window.innerWidth * .95) / (window.innerHeight * .9))) \n\n    const canvas = this.refs.maze\n    const c = canvas.getContext('2d');\n\n    if(rows < 15 || rows > 50){\n      swal({\n        button: false, \n        content: (\n          <div className=\"p-2 bg-white\">\n            <h3 className=\"bg-white\">Rows should be minimum 15 and maximum 50.</h3>\n          </div>\n        )\n      })\n      return\n    }\n    setUp({c , canvas , cols , rows, width , height , select_draw_algorithims , \n    check_recursive_delay: this.check_recursive_delay , speed })\n  }\n\n  render(){\n    let {width , height , select_solve_algorithims , select_draw_algorithims , dispay_draw_button} = this.state\n    let {solve_maze_algorithims , draw_maze_algorithims} = this.props\n    let speed = [\"Slow\", \"Normal\", \"Fast\" , \"Very Fast\"]\n    \n    let [start_x , start_y] = [this.state.start_location.x , this.state.start_location.y]\n\n    let [end_x , end_y]  = [this.state.end_location.x , this.state.end_location.y]\n\n    return(\n      <div className=\"mt-3\">\n        <div className=\"container border-right border-bottom p-3 border-secondary shadow-sm p-3 mb-5\">\n          <h2 className=\"ml-2\">The Maze Generatetor</h2>\n          <div className=\"row\">\n            {/* Generate maze controller */}\n            <div className=\"col border-right\">\n              <div class=\"form-group\">\n                <label>Algorithms</label>\n                <select \n                  className=\"custom-select\" \n                  style={{minWidth: 250}}\n                  onChange={(e) => this.setState({select_draw_algorithims: e.target.value})}\n                >\n                  {draw_maze_algorithims.map(algorithm => \n                    select_draw_algorithims === \" Default Grid \"\n                      ? <option value={algorithm} selected>{algorithm}</option>\n                      : <option value={algorithm}>{algorithm}</option>\n                  )}\n                </select>\n              </div>\n              <div class=\"form-group\">\n                <label for=\"exampleInputPassword1\">Speed</label>\n                <select \n                  className=\"custom-select\" \n                  onChange={(e) => this.setState({generate_speed: e.target.value})}\n                >\n                  {speed.map(s => \n                    s === \"Normal\"\n                      ? <option value={s} selected>{s}</option>\n                      : <option value={s} >{s}</option>\n                  )}\n                </select>\n              </div>\n              <div className=\"form-group\">\n                <label for=\"exampleInputPassword1\">Rows</label>\n                <input \n                  type=\"number\" \n                  className=\"form-control\" \n                  min='15' max='50'\n                  placeholder=\"Minimum 15 and Maximum 50\"\n                  style={{minWidth: 100}}\n                  onChange={(e) => {\n                    let rows = Math.floor(e.target.value)\n                    this.setState({rows})\n                  }}\n                ></input>\n              </div>\n              <div className=\"input-group-append\">\n                <button \n                  className=\"btn btn-outline-dark w-100 my-3\" \n                  onClick={() => {\n                    display_points = true\n                    if(dispay_draw_button){\n                      select_start = select_end = select_wall = false\n                      this.updateCanvas()\n                      this.run_set_point()\n                    }\n                  }}\n                >\n                  Generate Maze\n                </button>\n              </div>\n            </div>\n            \n            {/* Solve maze controller */}\n            <div className=\"col\">\n              <div class=\"form-group\">\n                <label>Algorithms</label>\n                <select \n                  className=\"custom-select\" \n                  onChange={(e) => this.setState({select_solve_algorithims: e.target.value})}\n                >\n                  {solve_maze_algorithims.map(algorithm => \n                    <option value={algorithm}>{algorithm}</option>\n                  )}\n                </select>\n              </div>\n              <div className=\"form-group\">\n                <label for=\"exampleInputPassword1\">Speed</label>\n                <select \n                  className=\"custom-select\" \n                  onChange={(e) => this.setState({solve_speed: this.state.speeds[e.target.value]})}\n                >\n                  {speed.map(s => \n                    s === \"Normal\"\n                      ? <option value={s} selected>{s}</option>\n                      : <option value={s} >{s}</option>\n                  )}\n                </select>\n              </div>\n              <div className = \"form-group\">\n                <label>Select start and end points</label><br/>\n\n              {/* Start point button */}\n                <button \n                  className=\"btn mx-2\" \n                  style={{color: select_start ? 'black' :'white'}}\n                  onClick={() => {\n                    select_end = select_wall = false\n                    select_start = !select_start\n                    this.setState({})\n                  }}\n                >\n                  <i class=\"fas fa-star\" style={{color: select_start ? 'black' :'white'}}></i> Start Point\n                </button>\n\n              {/* End point button */}\n                <button \n                  className=\"btn mx-2\" \n                  style={{color: select_end ? 'black' :'white'}}\n                  onClick={() => {\n                    select_start = select_wall = false\n                    select_end = !select_end \n                    this.setState({})\n                  }}\n                >\n                  <i class=\"fas fa-bullseye\" style={{color: select_end ? 'black' :'white'}}></i> End Point\n                </button>\n                \n              {/* Wall button */}\n              {select_draw_algorithims === \" Default Grid \" ? \n                <button \n                  className=\"btn mx-2\" \n                  style={{color: select_wall ? 'black' :'white'}}\n                  onClick={() => {\n                    select_end = select_start = false\n                    select_wall = !select_wall\n                    this.setState({})\n                  }}\n                >\n                  <i class=\"fas fa-square\" style={{color: select_wall ? 'black' :'white'}}></i> Walls\n                </button>\n              : null} \n                <label className=\"text-info\">\n                  {select_solve_algorithims === \" Self-Solve \" ? \"Use W | S to control forward and backward A | D for left and right.\" : \"\"}\n                </label>\n              </div>\n              <div className=\"input-group-append\">\n                <button \n                  className=\"btn btn-outline-dark w-100\" \n                  type=\"button\"\n                  onClick={() => {\n                    run_solve_maze(select_solve_algorithims , this.state.solve_speed)\n                  }}\n                >\n                  Solve Maze\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* Maze canvas */}\n        <div className=\"m-5\">\n          {display_points ? \n            <i \n              class=\"fas fa-star text-white\" \n              style={{position: \"absolute\", width: 10 , height: 10, top: start_y - 10, left: start_x - 10 , backgroundColor: 'transparent'}}></i>\n          : null } \n          {display_points ? \n            <i \n              class=\"fas fa-bullseye text-white\" \n              style={{position: \"absolute\", width: 6, height: 6, top: end_y - 6, left: end_x - 6 , backgroundColor: 'transparent'}}></i>\n          : null }\n          <canvas ref=\"maze\" style={{width, height}}></canvas>\n        </div> \n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = state => {\n  return {\n    draw_maze_algorithims: state.draw_maze_algorithims,\n    solve_maze_algorithims: state.solve_maze_algorithims,\n    speed: state.speed \n  }\n}\n\nexport default connect(mapStateToProps)(App)\n","let init_state = {\n    draw_maze_algorithims: [\"Depth first search\" , \"Prim's\" , \"Recursive Division\" , \" Default Grid \"], \n    solve_maze_algorithims: [\"A star\" , \"Depth first search\" , \"Breadth first search\" , \"Dijkstra's\" , \"Greedy best first search\" , \"Bidirectional a star\" , \"Bidirectional dijkstra's\", \" Self-Solve \"], \n    rows: 15,\n    speed: {\n        \"Depth first search\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Very Fast\": 300\n        },\n        \"Prim's\": {\n            \"Slow\": 10, \n            \"Normal\": 50, \n            \"Fast\": 150, \n            \"Very Fast\": 300\n        },\n        \"Recursive Division\": {\n            \"Very Fast\": 10, \n            \"Fast\": 50, \n            \"Normal\": 150, \n            \"Slow\": 300\n        },\n        \" Default Grid \": {\n            \"Very Fast\": 0, \n            \"Fast\": 0, \n            \"Normal\": 0, \n            \"Slow\": 0\n        }\n    }\n}\n\nconst mazeGenerationReducer = (state = init_state , action) => {\n    return state \n}\n\nexport default mazeGenerationReducer","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nimport {createStore} from 'redux'\nimport {Provider} from 'react-redux'\n\nimport mazeGeneratorReducer from './reducer/mazeGeneratorReducer'\n\nlet store = createStore(              //==> take reducer\n  mazeGeneratorReducer,\n  window._REDUX_DEVTOOLS_EXTENSION_ && window._REDUX_DEVTOOLS_EXTENSION_()\n)\n\nReactDOM.render(\n  <Provider store = {store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}